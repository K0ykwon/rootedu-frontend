From 31e30fe7bd3ac2efe977105d1fc3ef11f8af42e7 Mon Sep 17 00:00:00 2001
From: ssssanghyun <ahstmxj1597@yonsei.ac.kr>
Date: Mon, 15 Sep 2025 17:47:08 +0900
Subject: [PATCH] feat: Add Christine AI learning tools
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- Added ChristineAILearningTool component
- Integrated Christine's AI features in influencer page
- Added API endpoint for Christine-specific functionality
- Enhanced tab navigation to support Christine's AI tools

ğŸ¤– Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
---
 .../christine/core-phrase/route.ts            | 358 +++++++++
 .../influencers/christine/roleplay/route.ts   | 378 +++++++++
 .../influencers/christine/vocabulary/route.ts | 508 +++++++++++++
 app/influencers/[slug]/page.tsx               |  10 +-
 .../christine/ChristineAILearningTool.tsx     | 299 ++++++++
 components/christine/ChristineVocabulary.tsx  | 715 ++++++++++++++++++
 .../christine/CorePhrasePatternPractice.tsx   | 662 ++++++++++++++++
 components/christine/RolePlayConversation.tsx | 601 +++++++++++++++
 8 files changed, 3530 insertions(+), 1 deletion(-)
 create mode 100644 app/api/influencers/christine/core-phrase/route.ts
 create mode 100644 app/api/influencers/christine/roleplay/route.ts
 create mode 100644 app/api/influencers/christine/vocabulary/route.ts
 create mode 100644 components/christine/ChristineAILearningTool.tsx
 create mode 100644 components/christine/ChristineVocabulary.tsx
 create mode 100644 components/christine/CorePhrasePatternPractice.tsx
 create mode 100644 components/christine/RolePlayConversation.tsx

diff --git a/app/api/influencers/christine/core-phrase/route.ts b/app/api/influencers/christine/core-phrase/route.ts
new file mode 100644
index 0000000..c7bd377
--- /dev/null
+++ b/app/api/influencers/christine/core-phrase/route.ts
@@ -0,0 +1,358 @@
+import { NextRequest, NextResponse } from 'next/server';
+import { getRedisClient } from '@/lib/redis';
+import OpenAI from 'openai';
+
+const openai = new OpenAI({
+  apiKey: process.env.OPENAI_API_KEY,
+});
+
+interface PracticeQuestion {
+  id: string;
+  type: 'fill_blank' | 'complete_sentence' | 'variation';
+  originalPhrase: string;
+  question: string;
+  answer: string;
+  options?: string[];
+  explanation?: string;
+}
+
+interface PracticeProgress {
+  monthKey: string;
+  weekKey: string;
+  completedQuestions: string[];
+  score: number;
+  lastStudied: number;
+}
+
+export async function GET(request: NextRequest): Promise<NextResponse> {
+  try {
+    const url = new URL(request.url);
+    const userId = url.searchParams.get('userId');
+    const action = url.searchParams.get('action');
+    const month = url.searchParams.get('month');
+    const week = url.searchParams.get('week');
+
+    if (!userId) {
+      return NextResponse.json({
+        success: false,
+        error: 'ì‚¬ìš©ì IDê°€ í•„ìš”í•©ë‹ˆë‹¤.'
+      }, { status: 400 });
+    }
+
+    switch (action) {
+      case 'progress':
+        return await getProgress(userId, month!, week!);
+      default:
+        return NextResponse.json({
+          success: false,
+          error: 'ì§€ì›í•˜ì§€ ì•ŠëŠ” ì•¡ì…˜ì…ë‹ˆë‹¤.'
+        }, { status: 400 });
+    }
+
+  } catch (error) {
+    console.error('Core phrase GET error:', error);
+    return NextResponse.json({
+      success: false,
+      error: 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
+    }, { status: 500 });
+  }
+}
+
+export async function POST(request: NextRequest): Promise<NextResponse> {
+  try {
+    const body = await request.json();
+    const { action, userId } = body;
+
+    if (!userId) {
+      return NextResponse.json({
+        success: false,
+        error: 'ì‚¬ìš©ì IDê°€ í•„ìš”í•©ë‹ˆë‹¤.'
+      }, { status: 400 });
+    }
+
+    switch (action) {
+      case 'generate_questions':
+        return await generateQuestions(body);
+      case 'calculate_results':
+        return await calculateResults(body);
+      default:
+        return NextResponse.json({
+          success: false,
+          error: 'ì§€ì›í•˜ì§€ ì•ŠëŠ” ì•¡ì…˜ì…ë‹ˆë‹¤.'
+        }, { status: 400 });
+    }
+
+  } catch (error) {
+    console.error('Core phrase API error:', error);
+    return NextResponse.json({
+      success: false,
+      error: 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
+    }, { status: 500 });
+  }
+}
+
+async function getProgress(userId: string, month: string, week: string): Promise<NextResponse> {
+  try {
+    const redis = await getRedisClient();
+    const progressKey = `christine:core_phrase:${userId}:${month}:${week}`;
+
+    const progressData = await redis.hGetAll(progressKey);
+    await redis.quit();
+
+    if (Object.keys(progressData).length === 0) {
+      return NextResponse.json({
+        success: true,
+        progress: null
+      });
+    }
+
+    const progress: PracticeProgress = {
+      monthKey: month,
+      weekKey: week,
+      completedQuestions: JSON.parse(progressData.completedQuestions || '[]'),
+      score: parseInt(progressData.score || '0'),
+      lastStudied: parseInt(progressData.lastStudied || '0')
+    };
+
+    return NextResponse.json({
+      success: true,
+      progress
+    });
+
+  } catch (error) {
+    console.error('Get progress error:', error);
+    return NextResponse.json({
+      success: false,
+      error: 'ì§„ë„ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
+    }, { status: 500 });
+  }
+}
+
+async function generateQuestions(requestData: any): Promise<NextResponse> {
+  const { userId, month, week, phrases, count = 10 } = requestData;
+
+  try {
+    // Generate questions using AI
+    const questions = await generateQuestionsWithAI(phrases, count, month, week);
+
+    return NextResponse.json({
+      success: true,
+      questions,
+      message: `${questions.length}ê°œì˜ ë¬¸ì œê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.`
+    });
+
+  } catch (error) {
+    console.error('Generate questions error:', error);
+    return NextResponse.json({
+      success: false,
+      error: 'ë¬¸ì œ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
+    }, { status: 500 });
+  }
+}
+
+async function calculateResults(requestData: any): Promise<NextResponse> {
+  const { userId, month, week, questions, userAnswers } = requestData;
+
+  try {
+    let correctCount = 0;
+    const completedQuestions: string[] = [];
+
+    // Calculate score
+    for (const question of questions) {
+      const userAnswer = userAnswers[question.id];
+      if (userAnswer) {
+        completedQuestions.push(question.id);
+
+        // Check if answer is correct
+        if (question.options) {
+          // Multiple choice - check exact match
+          if (userAnswer === question.answer) {
+            correctCount++;
+          }
+        } else {
+          // Text input - check similarity or exact match
+          const similarity = calculateStringSimilarity(userAnswer.toLowerCase().trim(), question.answer.toLowerCase().trim());
+          if (similarity > 0.8) { // 80% similarity threshold
+            correctCount++;
+          }
+        }
+      }
+    }
+
+    const score = Math.round((correctCount / questions.length) * 100);
+
+    // Save progress to Redis
+    const redis = await getRedisClient();
+    const progressKey = `christine:core_phrase:${userId}:${month}:${week}`;
+
+    const progress: PracticeProgress = {
+      monthKey: month,
+      weekKey: week,
+      completedQuestions,
+      score,
+      lastStudied: Date.now()
+    };
+
+    await redis.hSet(progressKey, {
+      completedQuestions: JSON.stringify(completedQuestions),
+      score: score.toString(),
+      lastStudied: Date.now().toString()
+    });
+
+    await redis.quit();
+
+    return NextResponse.json({
+      success: true,
+      progress,
+      correctCount,
+      totalQuestions: questions.length,
+      message: `${correctCount}/${questions.length} ì •ë‹µ! ${score}ì ì„ íšë“í–ˆìŠµë‹ˆë‹¤.`
+    });
+
+  } catch (error) {
+    console.error('Calculate results error:', error);
+    return NextResponse.json({
+      success: false,
+      error: 'ê²°ê³¼ ê³„ì‚° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
+    }, { status: 500 });
+  }
+}
+
+async function generateQuestionsWithAI(phrases: string[], count: number, month: string, week: string): Promise<PracticeQuestion[]> {
+  try {
+    const completion = await openai.chat.completions.create({
+      model: 'gpt-4o-mini',
+      messages: [
+        {
+          role: 'system',
+          content: `You are Christine, an expert English conversation teacher specializing in practical English patterns for Korean learners.
+
+Create ${count} diverse practice questions based on the given phrases from ${month} ${week} curriculum.
+
+Generate 3 types of questions:
+1. Fill-in-blank: Remove 1-2 key words and provide multiple choice options
+2. Complete sentence: Give a situation and ask to complete using the pattern
+3. Variation: Ask for alternative ways to express the same meaning
+
+For each question, provide:
+- type: "fill_blank", "complete_sentence", or "variation"
+- originalPhrase: the source phrase
+- question: the question text in Korean
+- answer: the correct answer
+- options: array of 4 choices (for multiple choice questions)
+- explanation: helpful tip in Korean
+
+Respond in JSON format:
+{
+  "questions": [
+    {
+      "type": "fill_blank",
+      "originalPhrase": "I'd like to check in.",
+      "question": "ë‹¤ìŒ ë¹ˆì¹¸ì— ì•Œë§ì€ ë‹¨ì–´ë¥¼ ì„ íƒí•˜ì„¸ìš”: I'd ____ to check in.",
+      "answer": "like",
+      "options": ["like", "want", "need", "wish"],
+      "explanation": "'I'd like to'ëŠ” ì •ì¤‘í•œ ìš”ì²­ í‘œí˜„ì…ë‹ˆë‹¤."
+    }
+  ]
+}`
+        },
+        {
+          role: 'user',
+          content: `Create practice questions for these phrases:
+${phrases.join('\n')}
+
+Theme: ${month} ${week}
+Focus on practical usage and natural conversation patterns.`
+        }
+      ],
+      max_tokens: 2000,
+      temperature: 0.7,
+    });
+
+    const response = completion.choices[0]?.message?.content;
+
+    if (!response) {
+      throw new Error('AI response is empty');
+    }
+
+    const aiData = JSON.parse(response);
+
+    return aiData.questions.map((q: any, index: number) => ({
+      id: `${Date.now()}-${index}`,
+      type: q.type,
+      originalPhrase: q.originalPhrase,
+      question: q.question,
+      answer: q.answer,
+      options: q.options,
+      explanation: q.explanation
+    }));
+
+  } catch (error) {
+    console.error('AI question generation error:', error);
+
+    // Fallback questions
+    return generateFallbackQuestions(phrases, count);
+  }
+}
+
+function generateFallbackQuestions(phrases: string[], count: number): PracticeQuestion[] {
+  const fallbackQuestions: PracticeQuestion[] = [];
+
+  for (let i = 0; i < Math.min(count, phrases.length); i++) {
+    const phrase = phrases[i];
+    const words = phrase.split(' ');
+
+    if (words.length >= 3) {
+      // Generate fill-in-blank question
+      const keyWordIndex = Math.floor(words.length / 2);
+      const keyWord = words[keyWordIndex];
+      const questionPhrase = words.map((w, idx) => idx === keyWordIndex ? '____' : w).join(' ');
+
+      fallbackQuestions.push({
+        id: `fallback-${Date.now()}-${i}`,
+        type: 'fill_blank',
+        originalPhrase: phrase,
+        question: `ë‹¤ìŒ ë¹ˆì¹¸ì— ì•Œë§ì€ ë‹¨ì–´ë¥¼ ì„ íƒí•˜ì„¸ìš”: "${questionPhrase}"`,
+        answer: keyWord,
+        options: [keyWord, 'is', 'the', 'can'].filter((w, idx, arr) => arr.indexOf(w) === idx),
+        explanation: 'ë¬¸ë§¥ì— ë§ëŠ” ë‹¨ì–´ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.'
+      });
+    }
+  }
+
+  return fallbackQuestions;
+}
+
+function calculateStringSimilarity(str1: string, str2: string): number {
+  if (str1 === str2) return 1;
+  if (str1.includes(str2) || str2.includes(str1)) return 0.9;
+
+  // Simple Levenshtein distance approximation
+  const longer = str1.length > str2.length ? str1 : str2;
+  const shorter = str1.length > str2.length ? str2 : str1;
+
+  if (longer.length === 0) return 1;
+
+  const distance = levenshteinDistance(longer, shorter);
+  return (longer.length - distance) / longer.length;
+}
+
+function levenshteinDistance(str1: string, str2: string): number {
+  const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));
+
+  for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
+  for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
+
+  for (let j = 1; j <= str2.length; j++) {
+    for (let i = 1; i <= str1.length; i++) {
+      const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
+      matrix[j][i] = Math.min(
+        matrix[j][i - 1] + 1,
+        matrix[j - 1][i] + 1,
+        matrix[j - 1][i - 1] + indicator
+      );
+    }
+  }
+
+  return matrix[str2.length][str1.length];
+}
\ No newline at end of file
diff --git a/app/api/influencers/christine/roleplay/route.ts b/app/api/influencers/christine/roleplay/route.ts
new file mode 100644
index 0000000..b340585
--- /dev/null
+++ b/app/api/influencers/christine/roleplay/route.ts
@@ -0,0 +1,378 @@
+import { NextRequest, NextResponse } from 'next/server';
+import { getRedisClient } from '@/lib/redis';
+import { v4 as uuidv4 } from 'uuid';
+import OpenAI from 'openai';
+
+const openai = new OpenAI({
+  apiKey: process.env.OPENAI_API_KEY,
+});
+
+interface ConversationMessage {
+  id: string;
+  role: 'user' | 'ai' | 'system';
+  content: string;
+  timestamp: number;
+  feedback?: MessageFeedback;
+}
+
+interface MessageFeedback {
+  score: number;
+  naturalness: string;
+  suggestions: string[];
+  improvedVersion?: string;
+}
+
+interface ConversationSession {
+  id: string;
+  scenario: string;
+  context: string;
+  difficulty: string;
+  messages: ConversationMessage[];
+  totalScore: number;
+  completedTurns: number;
+  startTime: number;
+}
+
+const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
+
+export async function POST(request: NextRequest): Promise<NextResponse> {
+  try {
+    const body = await request.json();
+    const { action, userId } = body;
+
+    if (!userId) {
+      return NextResponse.json({
+        success: false,
+        error: 'ì‚¬ìš©ì IDê°€ í•„ìš”í•©ë‹ˆë‹¤.'
+      }, { status: 400 });
+    }
+
+    switch (action) {
+      case 'start_conversation':
+        return await startConversation(body);
+      case 'send_message':
+        return await sendMessage(body);
+      case 'get_feedback':
+        return await getFeedback(body);
+      default:
+        return NextResponse.json({
+          success: false,
+          error: 'ì§€ì›í•˜ì§€ ì•ŠëŠ” ì•¡ì…˜ì…ë‹ˆë‹¤.'
+        }, { status: 400 });
+    }
+
+  } catch (error) {
+    console.error('Roleplay API error:', error);
+    return NextResponse.json({
+      success: false,
+      error: 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
+    }, { status: 500 });
+  }
+}
+
+async function startConversation(requestData: any): Promise<NextResponse> {
+  const { userId, scenario, context, difficulty = 'intermediate' } = requestData;
+
+  try {
+    const sessionId = uuidv4();
+    const now = Date.now();
+
+    // Generate initial AI message
+    const initialMessage = await generateInitialMessage(scenario, context, difficulty);
+
+    const session: ConversationSession = {
+      id: sessionId,
+      scenario,
+      context,
+      difficulty,
+      messages: [
+        {
+          id: uuidv4(),
+          role: 'system',
+          content: `ğŸ­ Role-play ì‹œì‘: ${context}`,
+          timestamp: now
+        },
+        {
+          id: uuidv4(),
+          role: 'ai',
+          content: initialMessage,
+          timestamp: now + 1000
+        }
+      ],
+      totalScore: 0,
+      completedTurns: 0,
+      startTime: now
+    };
+
+    // Save session to Redis
+    const redis = await getRedisClient();
+    await redis.setEx(
+      `christine:roleplay:${sessionId}`,
+      SESSION_TIMEOUT / 1000,
+      JSON.stringify(session)
+    );
+    await redis.quit();
+
+    return NextResponse.json({
+      success: true,
+      session,
+      message: 'ìƒˆë¡œìš´ Role-play ì„¸ì…˜ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.'
+    });
+
+  } catch (error) {
+    console.error('Start conversation error:', error);
+    return NextResponse.json({
+      success: false,
+      error: 'ëŒ€í™” ì‹œì‘ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
+    }, { status: 500 });
+  }
+}
+
+async function sendMessage(requestData: any): Promise<NextResponse> {
+  const { userId, sessionId, message } = requestData;
+
+  try {
+    const redis = await getRedisClient();
+    const sessionKey = `christine:roleplay:${sessionId}`;
+    const sessionData = await redis.get(sessionKey);
+
+    if (!sessionData) {
+      await redis.quit();
+      return NextResponse.json({
+        success: false,
+        error: 'ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
+      }, { status: 404 });
+    }
+
+    const session: ConversationSession = JSON.parse(sessionData);
+    const now = Date.now();
+
+    // Add user message
+    const userMessage: ConversationMessage = {
+      id: uuidv4(),
+      role: 'user',
+      content: message,
+      timestamp: now
+    };
+
+    session.messages.push(userMessage);
+
+    // Generate AI response
+    const aiResponse = await generateAIResponse(session, message);
+
+    const aiMessage: ConversationMessage = {
+      id: uuidv4(),
+      role: 'ai',
+      content: aiResponse,
+      timestamp: now + 1000
+    };
+
+    session.messages.push(aiMessage);
+    session.completedTurns++;
+
+    // Update session in Redis
+    await redis.setEx(sessionKey, SESSION_TIMEOUT / 1000, JSON.stringify(session));
+    await redis.quit();
+
+    return NextResponse.json({
+      success: true,
+      session,
+      message: 'ë©”ì‹œì§€ê°€ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.'
+    });
+
+  } catch (error) {
+    console.error('Send message error:', error);
+    return NextResponse.json({
+      success: false,
+      error: 'ë©”ì‹œì§€ ì „ì†¡ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
+    }, { status: 500 });
+  }
+}
+
+async function getFeedback(requestData: any): Promise<NextResponse> {
+  const { userId, sessionId, messageId } = requestData;
+
+  try {
+    const redis = await getRedisClient();
+    const sessionKey = `christine:roleplay:${sessionId}`;
+    const sessionData = await redis.get(sessionKey);
+
+    if (!sessionData) {
+      await redis.quit();
+      return NextResponse.json({
+        success: false,
+        error: 'ì„¸ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
+      }, { status: 404 });
+    }
+
+    const session: ConversationSession = JSON.parse(sessionData);
+    const message = session.messages.find(m => m.id === messageId && m.role === 'user');
+
+    if (!message) {
+      await redis.quit();
+      return NextResponse.json({
+        success: false,
+        error: 'ë©”ì‹œì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
+      }, { status: 404 });
+    }
+
+    // Generate feedback
+    const feedback = await generateMessageFeedback(session, message.content);
+
+    // Update message with feedback
+    message.feedback = feedback;
+
+    // Update session in Redis
+    await redis.setEx(sessionKey, SESSION_TIMEOUT / 1000, JSON.stringify(session));
+    await redis.quit();
+
+    return NextResponse.json({
+      success: true,
+      session,
+      feedback,
+      message: 'í”¼ë“œë°±ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.'
+    });
+
+  } catch (error) {
+    console.error('Get feedback error:', error);
+    return NextResponse.json({
+      success: false,
+      error: 'í”¼ë“œë°± ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
+    }, { status: 500 });
+  }
+}
+
+async function generateInitialMessage(scenario: string, context: string, difficulty: string): Promise<string> {
+  try {
+    const completion = await openai.chat.completions.create({
+      model: 'gpt-4o-mini',
+      messages: [
+        {
+          role: 'system',
+          content: `You are Christine, a friendly and experienced English conversation teacher. You're helping Korean students practice English through role-play scenarios.
+
+Scenario: ${scenario}
+Context: ${context}
+Difficulty: ${difficulty}
+
+Generate a natural opening message to start the conversation. Use appropriate level of English for ${difficulty} learners. Be encouraging and set the scene clearly.
+
+Response should be 1-2 sentences, natural and conversational.`
+        }
+      ],
+      max_tokens: 200,
+      temperature: 0.8,
+    });
+
+    return completion.choices[0]?.message?.content || "Hello! Let's start our role-play practice. How can I help you today?";
+
+  } catch (error) {
+    console.error('Initial message generation error:', error);
+    return "Hello! Let's start our role-play practice. How can I help you today?";
+  }
+}
+
+async function generateAIResponse(session: ConversationSession, userMessage: string): Promise<string> {
+  try {
+    // Get recent conversation history
+    const recentMessages = session.messages
+      .filter(m => m.role !== 'system')
+      .slice(-6) // Last 6 messages for context
+      .map(m => `${m.role === 'user' ? 'Student' : 'Christine'}: ${m.content}`)
+      .join('\n');
+
+    const completion = await openai.chat.completions.create({
+      model: 'gpt-4o-mini',
+      messages: [
+        {
+          role: 'system',
+          content: `You are Christine, a patient and encouraging English conversation teacher conducting a role-play session.
+
+Scenario: ${session.scenario}
+Context: ${session.context}
+Difficulty: ${session.difficulty}
+
+Guidelines:
+- Respond naturally to continue the conversation
+- Match the scenario and context
+- Use appropriate difficulty level for ${session.difficulty} learners
+- Be encouraging and helpful
+- Keep responses 1-3 sentences
+- Stay in character for the role-play scenario
+
+Recent conversation:
+${recentMessages}
+
+Student just said: ${userMessage}
+
+Respond as Christine in the role-play scenario:`
+        }
+      ],
+      max_tokens: 300,
+      temperature: 0.8,
+    });
+
+    return completion.choices[0]?.message?.content || "That's great! Please continue.";
+
+  } catch (error) {
+    console.error('AI response generation error:', error);
+    return "That sounds good. What would you like to say next?";
+  }
+}
+
+async function generateMessageFeedback(session: ConversationSession, userMessage: string): Promise<MessageFeedback> {
+  try {
+    const completion = await openai.chat.completions.create({
+      model: 'gpt-4o-mini',
+      messages: [
+        {
+          role: 'system',
+          content: `You are Christine, an expert English teacher providing feedback on student conversation.
+
+Analyze this student message in the context of the role-play scenario and provide constructive feedback.
+
+Scenario: ${session.scenario}
+Context: ${session.context}
+Student message: "${userMessage}"
+
+Provide feedback in this JSON format:
+{
+  "score": 8,
+  "naturalness": "ìì—°ìŠ¤ëŸ¬ìš´ í‘œí˜„ì…ë‹ˆë‹¤. ì›ì–´ë¯¼ì´ ì‹¤ì œë¡œ ì‚¬ìš©í•˜ëŠ” í‘œí˜„ì´ì—ìš”.",
+  "suggestions": ["Consider using 'I'd like to' instead of 'I want to' for more politeness", "Try adding 'please' to make it sound more polite"],
+  "improvedVersion": "I'd like to check in, please."
+}
+
+Score: 1-10 (naturalness and appropriateness)
+Naturalness: Korean explanation of how natural the expression sounds
+Suggestions: 2-3 practical improvement tips in English
+ImprovedVersion: (optional) better version if significant improvement is needed`
+        }
+      ],
+      max_tokens: 500,
+      temperature: 0.3,
+    });
+
+    const response = completion.choices[0]?.message?.content;
+
+    if (response) {
+      return JSON.parse(response);
+    }
+
+    throw new Error('Empty AI response');
+
+  } catch (error) {
+    console.error('Feedback generation error:', error);
+
+    // Fallback feedback
+    return {
+      score: 7,
+      naturalness: 'ì¢‹ì€ í‘œí˜„ì…ë‹ˆë‹¤! ê³„ì† ì—°ìŠµí•˜ë©´ ë”ìš± ìì—°ìŠ¤ëŸ¬ì›Œì§ˆ ê±°ì˜ˆìš”.',
+      suggestions: [
+        'ë” ë‹¤ì–‘í•œ í‘œí˜„ì„ ì‚¬ìš©í•´ë³´ì„¸ìš”.',
+        'ë¬¸ì¥ì„ ì¡°ê¸ˆ ë” ê¸¸ê²Œ ë§Œë“¤ì–´ë³´ë©´ ì¢‹ê² ì–´ìš”.'
+      ],
+      improvedVersion: userMessage
+    };
+  }
+}
\ No newline at end of file
diff --git a/app/api/influencers/christine/vocabulary/route.ts b/app/api/influencers/christine/vocabulary/route.ts
new file mode 100644
index 0000000..bb9f459
--- /dev/null
+++ b/app/api/influencers/christine/vocabulary/route.ts
@@ -0,0 +1,508 @@
+import { NextRequest, NextResponse } from 'next/server';
+import { getRedisClient } from '@/lib/redis';
+import OpenAI from 'openai';
+
+const openai = new OpenAI({
+  apiKey: process.env.OPENAI_API_KEY,
+});
+
+// SRS intervals in days
+const SRS_INTERVALS = [1, 3, 7, 14, 30];
+
+interface VocabularyWord {
+  id: string;
+  word: string;
+  meaning: string;
+  category: 'travel' | 'smalltalk' | 'business';
+  subcategory: string;
+  pronunciation: string;
+  example: string;
+  translation: string;
+  difficulty: 'basic' | 'intermediate' | 'advanced';
+  createdAt: number;
+  nextReviewDate: number;
+  interval: number;
+  easinessFactor: number;
+  correctCount: number;
+  incorrectCount: number;
+  lastReviewed?: number;
+}
+
+interface StudyProgress {
+  totalWords: number;
+  todayStudied: number;
+  dueCount: number;
+  studyStreak: number;
+  categoryProgress: {
+    travel: number;
+    smalltalk: number;
+    business: number;
+  };
+}
+
+export async function GET(request: NextRequest): Promise<NextResponse> {
+  try {
+    const url = new URL(request.url);
+    const userId = url.searchParams.get('userId');
+    const action = url.searchParams.get('action');
+
+    if (!userId) {
+      return NextResponse.json({
+        success: false,
+        error: 'ì‚¬ìš©ì IDê°€ í•„ìš”í•©ë‹ˆë‹¤.'
+      }, { status: 400 });
+    }
+
+    switch (action) {
+      case 'progress':
+        return await getProgress(userId);
+      case 'due_words':
+        return await getDueWords(userId);
+      default:
+        return NextResponse.json({
+          success: false,
+          error: 'ì§€ì›í•˜ì§€ ì•ŠëŠ” ì•¡ì…˜ì…ë‹ˆë‹¤.'
+        }, { status: 400 });
+    }
+
+  } catch (error) {
+    console.error('Vocabulary GET error:', error);
+    return NextResponse.json({
+      success: false,
+      error: 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
+    }, { status: 500 });
+  }
+}
+
+export async function POST(request: NextRequest): Promise<NextResponse> {
+  try {
+    const body = await request.json();
+    const { action, userId } = body;
+
+    if (!userId) {
+      return NextResponse.json({
+        success: false,
+        error: 'ì‚¬ìš©ì IDê°€ í•„ìš”í•©ë‹ˆë‹¤.'
+      }, { status: 400 });
+    }
+
+    switch (action) {
+      case 'generate_study_words':
+        return await generateStudyWords(body);
+      case 'get_due_words':
+        return await getDueWords(userId);
+      case 'check_answer':
+        return await checkAnswer(body);
+      default:
+        return NextResponse.json({
+          success: false,
+          error: 'ì§€ì›í•˜ì§€ ì•ŠëŠ” ì•¡ì…˜ì…ë‹ˆë‹¤.'
+        }, { status: 400 });
+    }
+
+  } catch (error) {
+    console.error('Vocabulary API error:', error);
+    return NextResponse.json({
+      success: false,
+      error: 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
+    }, { status: 500 });
+  }
+}
+
+async function getProgress(userId: string): Promise<NextResponse> {
+  try {
+    const redis = await getRedisClient();
+
+    // Get all user's vocabulary words
+    const allWordIds = await redis.sMembers(`christine:vocab:${userId}:all`);
+    const now = Date.now();
+    let dueCount = 0;
+    const categoryProgress = { travel: 0, smalltalk: 0, business: 0 };
+
+    // Check due words and categorize
+    for (const wordId of allWordIds) {
+      const wordKey = `christine:vocab:${userId}:word:${wordId}`;
+      const wordData = await redis.hGetAll(wordKey);
+
+      if (wordData.word) {
+        const category = wordData.category as keyof typeof categoryProgress;
+        if (categoryProgress[category] !== undefined) {
+          categoryProgress[category]++;
+        }
+
+        const nextReviewDate = parseInt(wordData.nextReviewDate);
+        if (nextReviewDate <= now) {
+          dueCount++;
+        }
+      }
+    }
+
+    // Get today's studied count
+    const today = new Date().toDateString();
+    const todayStudied = await redis.sCard(`christine:vocab:${userId}:studied:${today}`);
+
+    // Calculate study streak (simplified)
+    const studyStreak = 1; // TODO: Implement proper streak calculation
+
+    const progress: StudyProgress = {
+      totalWords: allWordIds.length,
+      todayStudied,
+      dueCount,
+      studyStreak,
+      categoryProgress
+    };
+
+    await redis.quit();
+
+    return NextResponse.json({
+      success: true,
+      progress
+    });
+
+  } catch (error) {
+    console.error('Get progress error:', error);
+    return NextResponse.json({
+      success: false,
+      error: 'ì§„ë„ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
+    }, { status: 500 });
+  }
+}
+
+async function generateStudyWords(requestData: any): Promise<NextResponse> {
+  const { userId, category, subcategory, count = 10 } = requestData;
+
+  try {
+    // Generate vocabulary words using AI
+    const words = await generateVocabularyWithAI(category, subcategory, count);
+
+    // Save words to Redis
+    const redis = await getRedisClient();
+
+    for (const word of words) {
+      const wordKey = `christine:vocab:${userId}:word:${word.id}`;
+      await redis.hSet(wordKey, {
+        ...word,
+        createdAt: word.createdAt.toString(),
+        nextReviewDate: word.nextReviewDate.toString(),
+        interval: word.interval.toString(),
+        easinessFactor: word.easinessFactor.toString(),
+        correctCount: word.correctCount.toString(),
+        incorrectCount: word.incorrectCount.toString(),
+      });
+
+      // Add to user's word list
+      await redis.sAdd(`christine:vocab:${userId}:all`, word.id);
+
+      // Add to category-specific list
+      await redis.sAdd(`christine:vocab:${userId}:category:${category}`, word.id);
+    }
+
+    await redis.quit();
+
+    return NextResponse.json({
+      success: true,
+      words,
+      message: `${words.length}ê°œì˜ ìƒˆë¡œìš´ ë‹¨ì–´ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.`
+    });
+
+  } catch (error) {
+    console.error('Generate study words error:', error);
+    return NextResponse.json({
+      success: false,
+      error: 'ë‹¨ì–´ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
+    }, { status: 500 });
+  }
+}
+
+async function getDueWords(userId: string): Promise<NextResponse> {
+  try {
+    const redis = await getRedisClient();
+    const now = Date.now();
+
+    // Get all user's words
+    const allWordIds = await redis.sMembers(`christine:vocab:${userId}:all`);
+    const dueWords: VocabularyWord[] = [];
+
+    for (const wordId of allWordIds) {
+      const wordKey = `christine:vocab:${userId}:word:${wordId}`;
+      const wordData = await redis.hGetAll(wordKey);
+
+      if (wordData.word && parseInt(wordData.nextReviewDate) <= now) {
+        dueWords.push({
+          id: wordData.id,
+          word: wordData.word,
+          meaning: wordData.meaning,
+          category: wordData.category as any,
+          subcategory: wordData.subcategory,
+          pronunciation: wordData.pronunciation,
+          example: wordData.example,
+          translation: wordData.translation,
+          difficulty: wordData.difficulty as any,
+          createdAt: parseInt(wordData.createdAt),
+          nextReviewDate: parseInt(wordData.nextReviewDate),
+          interval: parseInt(wordData.interval),
+          easinessFactor: parseFloat(wordData.easinessFactor),
+          correctCount: parseInt(wordData.correctCount),
+          incorrectCount: parseInt(wordData.incorrectCount),
+          lastReviewed: wordData.lastReviewed ? parseInt(wordData.lastReviewed) : undefined
+        });
+      }
+    }
+
+    await redis.quit();
+
+    // Limit to 10 words and shuffle
+    const selectedWords = dueWords
+      .sort(() => Math.random() - 0.5)
+      .slice(0, 10);
+
+    return NextResponse.json({
+      success: true,
+      words: selectedWords
+    });
+
+  } catch (error) {
+    console.error('Get due words error:', error);
+    return NextResponse.json({
+      success: false,
+      error: 'ë³µìŠµí•  ë‹¨ì–´ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
+    }, { status: 500 });
+  }
+}
+
+async function checkAnswer(requestData: any): Promise<NextResponse> {
+  const { userId, wordId, userAnswer, timeSpent } = requestData;
+
+  try {
+    const redis = await getRedisClient();
+    const wordKey = `christine:vocab:${userId}:word:${wordId}`;
+    const wordData = await redis.hGetAll(wordKey);
+
+    if (!wordData.word) {
+      await redis.quit();
+      return NextResponse.json({
+        success: false,
+        error: 'ë‹¨ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
+      }, { status: 404 });
+    }
+
+    // Check if answer is correct
+    const correctAnswer = wordData.meaning.toLowerCase();
+    const userAnswerNorm = userAnswer.toLowerCase().trim();
+    const isCorrect = correctAnswer.includes(userAnswerNorm) || userAnswerNorm.includes(correctAnswer);
+
+    // Update SRS data
+    const updatedWord = await updateSRSData(redis, userId, wordId, isCorrect);
+
+    // Record today's study
+    const today = new Date().toDateString();
+    await redis.sAdd(`christine:vocab:${userId}:studied:${today}`, wordId);
+
+    await redis.quit();
+
+    return NextResponse.json({
+      success: true,
+      isCorrect,
+      correctAnswer: wordData.meaning,
+      updatedWord,
+      message: isCorrect ? 'ì •ë‹µì…ë‹ˆë‹¤!' : 'ë‹¤ì‹œ í•œë²ˆ ì—°ìŠµí•´ë³´ì„¸ìš”!'
+    });
+
+  } catch (error) {
+    console.error('Check answer error:', error);
+    return NextResponse.json({
+      success: false,
+      error: 'ë‹µë³€ í™•ì¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
+    }, { status: 500 });
+  }
+}
+
+async function generateVocabularyWithAI(category: string, subcategory: string | undefined, count: number): Promise<VocabularyWord[]> {
+  try {
+    const categoryMap = {
+      travel: 'ì—¬í–‰',
+      smalltalk: 'ì¼ìƒ ëŒ€í™”',
+      business: 'ë¹„ì¦ˆë‹ˆìŠ¤'
+    };
+
+    const completion = await openai.chat.completions.create({
+      model: 'gpt-4o-mini',
+      messages: [
+        {
+          role: 'system',
+          content: `You are Christine, an expert English vocabulary teacher for Korean learners.
+
+Create ${count} practical English vocabulary words for the category: ${categoryMap[category as keyof typeof categoryMap] || category}${subcategory ? ` (${subcategory})` : ''}.
+
+For each word, provide:
+1. English word
+2. Korean meaning
+3. Pronunciation (IPA or simple phonetic)
+4. Example sentence in English
+5. Korean translation of example
+6. Difficulty level (basic/intermediate/advanced)
+
+Response format (JSON only):
+{
+  "words": [
+    {
+      "word": "reservation",
+      "meaning": "ì˜ˆì•½",
+      "pronunciation": "ËŒrezÉ™rËˆveÉªÊƒÉ™n",
+      "example": "I have a reservation under Kim.",
+      "translation": "ê¹€ì”¨ ì´ë¦„ìœ¼ë¡œ ì˜ˆì•½í–ˆìŠµë‹ˆë‹¤.",
+      "difficulty": "intermediate"
+    }
+  ]
+}
+
+Focus on:
+- Practical, commonly used words
+- Words appropriate for the category
+- Clear, natural example sentences
+- Accurate Korean translations`
+        }
+      ],
+      max_tokens: 2000,
+      temperature: 0.8,
+    });
+
+    const response = completion.choices[0]?.message?.content;
+
+    if (!response) {
+      throw new Error('AI response is empty');
+    }
+
+    const aiData = JSON.parse(response);
+    const now = Date.now();
+
+    return aiData.words.map((word: any, index: number) => ({
+      id: `${Date.now()}-${index}`,
+      word: word.word,
+      meaning: word.meaning,
+      category: category as any,
+      subcategory: subcategory || 'general',
+      pronunciation: word.pronunciation,
+      example: word.example,
+      translation: word.translation,
+      difficulty: word.difficulty,
+      createdAt: now,
+      nextReviewDate: now + (24 * 60 * 60 * 1000), // Review tomorrow
+      interval: 1,
+      easinessFactor: 2.5,
+      correctCount: 0,
+      incorrectCount: 0
+    }));
+
+  } catch (error) {
+    console.error('AI vocabulary generation error:', error);
+
+    // Fallback words
+    const fallbackWords = [
+      {
+        word: 'hello',
+        meaning: 'ì•ˆë…•í•˜ì„¸ìš”',
+        pronunciation: 'hÉ™ËˆloÊŠ',
+        example: 'Hello, how are you?',
+        translation: 'ì•ˆë…•í•˜ì„¸ìš”, ì–´ë–»ê²Œ ì§€ë‚´ì„¸ìš”?',
+        difficulty: 'basic'
+      },
+      {
+        word: 'thank you',
+        meaning: 'ê°ì‚¬í•©ë‹ˆë‹¤',
+        pronunciation: 'Î¸Ã¦Å‹k juË',
+        example: 'Thank you very much.',
+        translation: 'ì •ë§ ê°ì‚¬í•©ë‹ˆë‹¤.',
+        difficulty: 'basic'
+      },
+      {
+        word: 'excuse me',
+        meaning: 'ì‹¤ë¡€í•©ë‹ˆë‹¤',
+        pronunciation: 'ÉªkËˆskjuËs miË',
+        example: 'Excuse me, where is the bathroom?',
+        translation: 'ì‹¤ë¡€í•©ë‹ˆë‹¤, í™”ì¥ì‹¤ì´ ì–´ë””ì¸ê°€ìš”?',
+        difficulty: 'basic'
+      }
+    ];
+
+    const now = Date.now();
+
+    return fallbackWords.slice(0, count).map((word, index) => ({
+      id: `${Date.now()}-${index}`,
+      word: word.word,
+      meaning: word.meaning,
+      category: category as any,
+      subcategory: subcategory || 'general',
+      pronunciation: word.pronunciation,
+      example: word.example,
+      translation: word.translation,
+      difficulty: word.difficulty as any,
+      createdAt: now,
+      nextReviewDate: now + (24 * 60 * 60 * 1000),
+      interval: 1,
+      easinessFactor: 2.5,
+      correctCount: 0,
+      incorrectCount: 0
+    }));
+  }
+}
+
+async function updateSRSData(redis: any, userId: string, wordId: string, isCorrect: boolean): Promise<VocabularyWord> {
+  const wordKey = `christine:vocab:${userId}:word:${wordId}`;
+  const wordData = await redis.hGetAll(wordKey);
+
+  if (!wordData.word) throw new Error('Word not found');
+
+  const correctCount = parseInt(wordData.correctCount) + (isCorrect ? 1 : 0);
+  const incorrectCount = parseInt(wordData.incorrectCount) + (isCorrect ? 0 : 1);
+  let easinessFactor = parseFloat(wordData.easinessFactor);
+  let interval = parseInt(wordData.interval);
+
+  // SRS algorithm (SM-2 based)
+  if (isCorrect) {
+    if (correctCount === 1) {
+      interval = 1;
+    } else if (correctCount === 2) {
+      interval = 3;
+    } else {
+      interval = Math.round(interval * easinessFactor);
+    }
+    easinessFactor = easinessFactor + (0.1 - (5 - 4) * (0.08 + (5 - 4) * 0.02));
+  } else {
+    interval = 1;
+    easinessFactor = Math.max(1.3, easinessFactor - 0.2);
+  }
+
+  const nextReviewDate = Date.now() + (interval * 24 * 60 * 60 * 1000);
+  const now = Date.now();
+
+  const updatedData = {
+    correctCount: correctCount.toString(),
+    incorrectCount: incorrectCount.toString(),
+    easinessFactor: easinessFactor.toString(),
+    interval: interval.toString(),
+    nextReviewDate: nextReviewDate.toString(),
+    lastReviewed: now.toString()
+  };
+
+  await redis.hSet(wordKey, updatedData);
+
+  return {
+    id: wordData.id,
+    word: wordData.word,
+    meaning: wordData.meaning,
+    category: wordData.category as any,
+    subcategory: wordData.subcategory,
+    pronunciation: wordData.pronunciation,
+    example: wordData.example,
+    translation: wordData.translation,
+    difficulty: wordData.difficulty as any,
+    createdAt: parseInt(wordData.createdAt),
+    nextReviewDate,
+    interval,
+    easinessFactor,
+    correctCount,
+    incorrectCount,
+    lastReviewed: now
+  };
+}
\ No newline at end of file
diff --git a/app/influencers/[slug]/page.tsx b/app/influencers/[slug]/page.tsx
index f420262..acbb796 100644
--- a/app/influencers/[slug]/page.tsx
+++ b/app/influencers/[slug]/page.tsx
@@ -14,6 +14,7 @@ import Skeleton from '../../../components/ui/Skeleton';
 import { MedskyAnalyzer } from '../../../components/medsky/MedskyAnalyzer';
 import { EnglishMemorizationTool } from '../../../components/terry/EnglishMemorizationTool';
 import { VocabularyMemoizer } from '../../../components/terry/VocabularyMemoizer';
+import { ChristineAILearningTool } from '../../../components/christine/ChristineAILearningTool';
 import ChatWidget from '../../../components/ChatWidget';
 
 interface Influencer {
@@ -476,8 +477,15 @@ export default function InfluencerDetailPage() {
                 </div>
               )}
 
+              {/* AI Features Tab - Christine's AI learning tools */}
+              {activeTab === 'ai_features' && influencer.slug === 'christine' && (
+                <div className="space-y-6">
+                  <ChristineAILearningTool />
+                </div>
+              )}
+
               {/* AI Features Tab - Coming Soon for other influencers */}
-              {activeTab === 'ai_features' && influencer.slug !== 'terry' && (
+              {activeTab === 'ai_features' && influencer.slug !== 'terry' && influencer.slug !== 'christine' && (
                 <div className="space-y-6">
                   <Card className="bg-white dark:bg-gray-900/50 border-gray-200 dark:border-gray-800 shadow-sm dark:shadow-none">
                     <div className="text-center py-16">
diff --git a/components/christine/ChristineAILearningTool.tsx b/components/christine/ChristineAILearningTool.tsx
new file mode 100644
index 0000000..cb5b940
--- /dev/null
+++ b/components/christine/ChristineAILearningTool.tsx
@@ -0,0 +1,299 @@
+'use client';
+
+/**
+ * Christine AI Learning Tool
+ *
+ * 3ê°€ì§€ í•µì‹¬ ê¸°ëŠ¥:
+ * 1. Core Phrase íŒ¨í„´ ì—°ìŠµ - ë³´ìœ  ë°ì´í„° ê¸°ë°˜ ë¹ˆì¹¸/ë¬¸ì¥ ìƒì„± ì—°ìŠµ
+ * 2. Role-play ëŒ€í™” - ìƒí™© ì…ë ¥ ê¸°ë°˜ ìì—°ìŠ¤ëŸ¬ìš´ ëŒ€í™” ë£¨í‹´ ìŠµë“
+ * 3. ë‹¨ì–´ ì•”ê¸° ì‹œìŠ¤í…œ - SRS ê¸°ë°˜ ì²´ê³„ì  ë‹¨ì–´ í•™ìŠµ
+ */
+
+import React, { useState, useEffect } from 'react';
+import { useSession, signIn } from 'next-auth/react';
+import Card from '@/components/ui/Card';
+import Button from '@/components/ui/Button';
+import Badge from '@/components/ui/Badge';
+import { CorePhrasePatternPractice } from './CorePhrasePatternPractice';
+import { RolePlayConversation } from './RolePlayConversation';
+import { ChristineVocabulary } from './ChristineVocabulary';
+
+type ToolType = 'menu' | 'core-phrase' | 'role-play' | 'vocabulary';
+
+export function ChristineAILearningTool() {
+  const { data: session, status: sessionStatus } = useSession();
+  const [currentTool, setCurrentTool] = useState<ToolType>('menu');
+
+  // Show loading while checking authentication
+  if (sessionStatus === 'loading') {
+    return (
+      <div className="flex items-center justify-center py-8">
+        <div className="text-[var(--color-text-primary)]">ë¡œë”© ì¤‘...</div>
+      </div>
+    );
+  }
+
+  // Show sign-in prompt if not authenticated
+  if (!session) {
+    return (
+      <Card className="p-8 text-center" glass={false}>
+        <div className="space-y-4">
+          <span className="text-6xl">ğŸ”’</span>
+          <h2 className="text-2xl font-bold text-[var(--color-text-primary)]">
+            ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤
+          </h2>
+          <p className="text-[var(--color-text-secondary)]">
+            Christineì˜ ë¬´ë£Œ AI ì˜ì–´ í•™ìŠµ ë„êµ¬ë¥¼ ì´ìš©í•˜ë ¤ë©´ ë¨¼ì € ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.
+          </p>
+          <Button
+            onClick={() => signIn()}
+            variant="primary"
+            size="lg"
+          >
+            ë¡œê·¸ì¸í•˜ê¸°
+          </Button>
+        </div>
+      </Card>
+    );
+  }
+
+  // Render tool selection menu
+  if (currentTool === 'menu') {
+    return (
+      <div className="space-y-6">
+        {/* Header */}
+        <Card className="p-6" glass={false}>
+          <div className="text-center space-y-4">
+            <div className="w-24 h-24 mx-auto bg-gradient-to-br from-pink-500/20 to-purple-500/20 rounded-full flex items-center justify-center">
+              <span className="text-5xl">ğŸ’¬</span>
+            </div>
+            <h2 className="text-2xl font-bold text-[var(--color-text-primary)]">
+              Christine AI ì˜ì–´ í•™ìŠµ ë„êµ¬
+            </h2>
+            <p className="text-[var(--color-text-secondary)] max-w-2xl mx-auto">
+              Christineê³¼ í•¨ê»˜í•˜ëŠ” ì‹¤ìš©ì ì¸ ì˜ì–´ íšŒí™” í•™ìŠµ!
+              ì²´ê³„ì ì¸ íŒ¨í„´ ì—°ìŠµë¶€í„° ì‹¤ì „ ëŒ€í™”ê¹Œì§€ ì™„ë²½ ë§ˆìŠ¤í„°í•˜ì„¸ìš”.
+            </p>
+            <div className="flex flex-wrap justify-center gap-2">
+              <Badge variant="primary" size="sm">ë¬´ë£Œ ì œê³µ</Badge>
+              <Badge variant="success" size="sm">AI ë§ì¶¤ í•™ìŠµ</Badge>
+              <Badge variant="warning" size="sm">ì‹¤ì „ íšŒí™” íŠ¹í™”</Badge>
+            </div>
+          </div>
+        </Card>
+
+        {/* Tool Selection */}
+        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
+          {/* Core Phrase Pattern Practice */}
+          <Card className="p-6 hover:shadow-lg transition-shadow cursor-pointer" glass={false}
+                onClick={() => setCurrentTool('core-phrase')}>
+            <div className="text-center space-y-4">
+              <div className="w-16 h-16 mx-auto bg-gradient-to-br from-blue-500/20 to-cyan-500/20 rounded-full flex items-center justify-center">
+                <span className="text-3xl">ğŸ“</span>
+              </div>
+              <h3 className="text-xl font-semibold text-[var(--color-text-primary)]">
+                Core Phrase íŒ¨í„´ ì—°ìŠµ
+              </h3>
+              <p className="text-[var(--color-text-secondary)]">
+                ì—¬í–‰, ìŠ¤ëª°í† í¬, ë¹„ì¦ˆë‹ˆìŠ¤ í•µì‹¬ íŒ¨í„´ì„ ì²´ê³„ì ìœ¼ë¡œ ì—°ìŠµí•˜ê³  ë³€í˜• í•™ìŠµí•˜ì„¸ìš”.
+              </p>
+              <div className="flex flex-wrap justify-center gap-2">
+                <Badge variant="info" size="sm">íŒ¨í„´ ë³€í˜•</Badge>
+                <Badge variant="success" size="sm">ë¹ˆì¹¸ ì±„ìš°ê¸°</Badge>
+                <Badge variant="warning" size="sm">ë¬¸ì¥ ìƒì„±</Badge>
+              </div>
+              <Button variant="primary" className="w-full">
+                ğŸ“ íŒ¨í„´ ì—°ìŠµ ì‹œì‘í•˜ê¸°
+              </Button>
+            </div>
+          </Card>
+
+          {/* Role-play Conversation */}
+          <Card className="p-6 hover:shadow-lg transition-shadow cursor-pointer" glass={false}
+                onClick={() => setCurrentTool('role-play')}>
+            <div className="text-center space-y-4">
+              <div className="w-16 h-16 mx-auto bg-gradient-to-br from-green-500/20 to-teal-500/20 rounded-full flex items-center justify-center">
+                <span className="text-3xl">ğŸ­</span>
+              </div>
+              <h3 className="text-xl font-semibold text-[var(--color-text-primary)]">
+                Role-play ëŒ€í™” ì—°ìŠµ
+              </h3>
+              <p className="text-[var(--color-text-secondary)]">
+                ìƒí™©ì„ ì…ë ¥í•˜ë©´ AIê°€ ë§ì¶¤í˜• ëŒ€í™”ë¥¼ ìƒì„±í•´ ìì—°ìŠ¤ëŸ¬ìš´ íšŒí™” ë£¨í‹´ì„ ìŠµë“í•˜ì„¸ìš”.
+              </p>
+              <div className="flex flex-wrap justify-center gap-2">
+                <Badge variant="primary" size="sm">ìƒí™©ë³„ ëŒ€í™”</Badge>
+                <Badge variant="success" size="sm">ì‹¤ì‹œê°„ í”¼ë“œë°±</Badge>
+                <Badge variant="warning" size="sm">ìì—°ìŠ¤ëŸ¬ìš´ í‘œí˜„</Badge>
+              </div>
+              <Button variant="primary" className="w-full">
+                ğŸ­ Role-play ì‹œì‘í•˜ê¸°
+              </Button>
+            </div>
+          </Card>
+
+          {/* Vocabulary Memorization */}
+          <Card className="p-6 hover:shadow-lg transition-shadow cursor-pointer" glass={false}
+                onClick={() => setCurrentTool('vocabulary')}>
+            <div className="text-center space-y-4">
+              <div className="w-16 h-16 mx-auto bg-gradient-to-br from-purple-500/20 to-pink-500/20 rounded-full flex items-center justify-center">
+                <span className="text-3xl">ğŸ“š</span>
+              </div>
+              <h3 className="text-xl font-semibold text-[var(--color-text-primary)]">
+                ì‹¤ìš© ë‹¨ì–´ ì•”ê¸° ì‹œìŠ¤í…œ
+              </h3>
+              <p className="text-[var(--color-text-secondary)]">
+                ì—¬í–‰, ë¹„ì¦ˆë‹ˆìŠ¤, ì¼ìƒ íšŒí™”ì— ê¼­ í•„ìš”í•œ ë‹¨ì–´ë“¤ì„ ì²´ê³„ì ìœ¼ë¡œ ì•”ê¸°í•˜ì„¸ìš”.
+              </p>
+              <div className="flex flex-wrap justify-center gap-2">
+                <Badge variant="primary" size="sm">SRS ë³µìŠµ</Badge>
+                <Badge variant="success" size="sm">ì‹¤ìš© ë‹¨ì–´</Badge>
+                <Badge variant="warning" size="sm">ìƒí™©ë³„ ë¶„ë¥˜</Badge>
+              </div>
+              <Button variant="primary" className="w-full">
+                ğŸ“š ë‹¨ì–´ ì•”ê¸° ì‹œì‘í•˜ê¸°
+              </Button>
+            </div>
+          </Card>
+        </div>
+
+        {/* Features Comparison */}
+        <Card className="p-6" glass={false}>
+          <h3 className="text-lg font-semibold text-[var(--color-text-primary)] mb-4">
+            ğŸ’¡ ë„êµ¬ë³„ íŠ¹ì§• ë¹„êµ
+          </h3>
+          <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
+            <div>
+              <h4 className="font-medium text-blue-600 dark:text-blue-400 mb-3">ğŸ“ Core Phrase íŒ¨í„´ ì—°ìŠµ</h4>
+              <ul className="space-y-2 text-sm text-[var(--color-text-secondary)]">
+                <li>â€¢ 3ê°œì›”ì°¨ ì²´ê³„ì  ì»¤ë¦¬í˜ëŸ¼ ê¸°ë°˜</li>
+                <li>â€¢ ì—¬í–‰/ìŠ¤ëª°í† í¬/ë¹„ì¦ˆë‹ˆìŠ¤ í•µì‹¬ íŒ¨í„´</li>
+                <li>â€¢ AI ìë™ ë³€í˜• ë¬¸ì œ ìƒì„±</li>
+                <li>â€¢ ë¹ˆì¹¸ ì±„ìš°ê¸° + ë¬¸ì¥ ì™„ì„±</li>
+                <li>â€¢ ë‹¨ê³„ë³„ ë‚œì´ë„ ì¡°ì ˆ</li>
+              </ul>
+            </div>
+            <div>
+              <h4 className="font-medium text-green-600 dark:text-green-400 mb-3">ğŸ­ Role-play ëŒ€í™” ì—°ìŠµ</h4>
+              <ul className="space-y-2 text-sm text-[var(--color-text-secondary)]">
+                <li>â€¢ ì‚¬ìš©ì ì…ë ¥ ìƒí™© ê¸°ë°˜ ëŒ€í™” ìƒì„±</li>
+                <li>â€¢ AIì™€ ì‹¤ì‹œê°„ ëŒ€í™” ì—°ìŠµ</li>
+                <li>â€¢ ìì—°ìŠ¤ëŸ¬ìš´ í‘œí˜„ í•™ìŠµ</li>
+                <li>â€¢ ë§ì¶¤í˜• í”¼ë“œë°± ì œê³µ</li>
+                <li>â€¢ ì‹¤ì „ íšŒí™” ëŠ¥ë ¥ í–¥ìƒ</li>
+              </ul>
+            </div>
+            <div>
+              <h4 className="font-medium text-purple-600 dark:text-purple-400 mb-3">ğŸ“š ì‹¤ìš© ë‹¨ì–´ ì•”ê¸°</h4>
+              <ul className="space-y-2 text-sm text-[var(--color-text-secondary)]">
+                <li>â€¢ SRS ì•Œê³ ë¦¬ì¦˜ ê¸°ë°˜ íš¨ìœ¨ì  ì•”ê¸°</li>
+                <li>â€¢ ìƒí™©ë³„ ë¶„ë¥˜ëœ ì‹¤ìš© ë‹¨ì–´</li>
+                <li>â€¢ ë¬¸ë§¥ ì¤‘ì‹¬ ì˜ˆë¬¸ ì œê³µ</li>
+                <li>â€¢ ê°œì¸ ë§ì¶¤ ë³µìŠµ ì¼ì •</li>
+                <li>â€¢ ì§„ë„ ì¶”ì  ë° ì„±ì·¨ ë¶„ì„</li>
+              </ul>
+            </div>
+          </div>
+        </Card>
+
+        {/* Christine's Specialties */}
+        <Card className="p-6 bg-gradient-to-br from-pink-50 to-purple-50 dark:from-pink-900/20 dark:to-purple-900/20" glass={false}>
+          <h3 className="text-lg font-semibold text-[var(--color-text-primary)] mb-4 flex items-center gap-2">
+            <span>ğŸ’</span> Christineë§Œì˜ íŠ¹ë³„í•¨
+          </h3>
+          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
+            <div>
+              <h4 className="font-medium text-pink-600 dark:text-pink-400 mb-2">ğŸŒŸ ì‹¤ì „ ì¤‘ì‹¬ í•™ìŠµ</h4>
+              <p className="text-sm text-[var(--color-text-secondary)]">
+                êµê³¼ì„œì ì¸ ì˜ì–´ê°€ ì•„ë‹Œ, ì‹¤ì œ ì›ì–´ë¯¼ë“¤ì´ ì‚¬ìš©í•˜ëŠ” ìì—°ìŠ¤ëŸ¬ìš´ í‘œí˜„ì„ ì¤‘ì‹¬ìœ¼ë¡œ í•™ìŠµí•©ë‹ˆë‹¤.
+              </p>
+            </div>
+            <div>
+              <h4 className="font-medium text-purple-600 dark:text-purple-400 mb-2">ğŸ¯ ìƒí™©ë³„ ë§ì¶¤ í•™ìŠµ</h4>
+              <p className="text-sm text-[var(--color-text-secondary)]">
+                ì—¬í–‰, ë¹„ì¦ˆë‹ˆìŠ¤, ì¼ìƒ ëŒ€í™” ë“± êµ¬ì²´ì ì¸ ìƒí™©ì— ë”°ë¼ í•„ìš”í•œ í‘œí˜„ì„ íš¨ê³¼ì ìœ¼ë¡œ í•™ìŠµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
+              </p>
+            </div>
+            <div>
+              <h4 className="font-medium text-pink-600 dark:text-pink-400 mb-2">ğŸ¤– AI ë§ì¶¤í˜• í”¼ë“œë°±</h4>
+              <p className="text-sm text-[var(--color-text-secondary)]">
+                ê°œì¸ì˜ í•™ìŠµ ìˆ˜ì¤€ê³¼ ì•½ì ì„ ë¶„ì„í•´ ë§ì¶¤í˜• ë¬¸ì œì™€ í”¼ë“œë°±ì„ ì œê³µí•©ë‹ˆë‹¤.
+              </p>
+            </div>
+            <div>
+              <h4 className="font-medium text-purple-600 dark:text-purple-400 mb-2">ğŸ“ˆ ì²´ê³„ì  ì§„ë„ ê´€ë¦¬</h4>
+              <p className="text-sm text-[var(--color-text-secondary)]">
+                í•™ìŠµ ì§„ë„ì™€ ì„±ì·¨ë„ë¥¼ ì²´ê³„ì ìœ¼ë¡œ ì¶”ì í•˜ì—¬ íš¨ê³¼ì ì¸ í•™ìŠµ ê²½ë¡œë¥¼ ì œì‹œí•©ë‹ˆë‹¤.
+              </p>
+            </div>
+          </div>
+        </Card>
+      </div>
+    );
+  }
+
+  // Render Core Phrase Pattern Practice
+  if (currentTool === 'core-phrase') {
+    return (
+      <div className="space-y-4">
+        <div className="flex items-center gap-4">
+          <Button
+            onClick={() => setCurrentTool('menu')}
+            variant="outline"
+            size="sm"
+          >
+            â† ë„êµ¬ ì„ íƒìœ¼ë¡œ
+          </Button>
+          <h2 className="text-xl font-semibold text-[var(--color-text-primary)]">
+            ğŸ“ Core Phrase íŒ¨í„´ ì—°ìŠµ
+          </h2>
+        </div>
+        <CorePhrasePatternPractice />
+      </div>
+    );
+  }
+
+  // Render Role-play Conversation
+  if (currentTool === 'role-play') {
+    return (
+      <div className="space-y-4">
+        <div className="flex items-center gap-4">
+          <Button
+            onClick={() => setCurrentTool('menu')}
+            variant="outline"
+            size="sm"
+          >
+            â† ë„êµ¬ ì„ íƒìœ¼ë¡œ
+          </Button>
+          <h2 className="text-xl font-semibold text-[var(--color-text-primary)]">
+            ğŸ­ Role-play ëŒ€í™” ì—°ìŠµ
+          </h2>
+        </div>
+        <RolePlayConversation />
+      </div>
+    );
+  }
+
+  // Render Vocabulary Memorization
+  if (currentTool === 'vocabulary') {
+    return (
+      <div className="space-y-4">
+        <div className="flex items-center gap-4">
+          <Button
+            onClick={() => setCurrentTool('menu')}
+            variant="outline"
+            size="sm"
+          >
+            â† ë„êµ¬ ì„ íƒìœ¼ë¡œ
+          </Button>
+          <h2 className="text-xl font-semibold text-[var(--color-text-primary)]">
+            ğŸ“š ì‹¤ìš© ë‹¨ì–´ ì•”ê¸° ì‹œìŠ¤í…œ
+          </h2>
+        </div>
+        <ChristineVocabulary />
+      </div>
+    );
+  }
+
+  return null;
+}
\ No newline at end of file
diff --git a/components/christine/ChristineVocabulary.tsx b/components/christine/ChristineVocabulary.tsx
new file mode 100644
index 0000000..1f3298c
--- /dev/null
+++ b/components/christine/ChristineVocabulary.tsx
@@ -0,0 +1,715 @@
+'use client';
+
+/**
+ * Christine Vocabulary Memorization Component
+ *
+ * Christineì˜ ì‹¤ìš© ë‹¨ì–´ ì•”ê¸° ì‹œìŠ¤í…œ:
+ * - SRS ì•Œê³ ë¦¬ì¦˜ ê¸°ë°˜ íš¨ìœ¨ì  ì•”ê¸°
+ * - ìƒí™©ë³„ ë¶„ë¥˜ëœ ì‹¤ìš© ë‹¨ì–´ (ì—¬í–‰/ìŠ¤ëª°í† í¬/ë¹„ì¦ˆë‹ˆìŠ¤)
+ * - ë¬¸ë§¥ ì¤‘ì‹¬ ì˜ˆë¬¸ ì œê³µ
+ * - ê°œì¸ ë§ì¶¤ ë³µìŠµ ì¼ì •
+ */
+
+import React, { useState, useEffect, useCallback } from 'react';
+import { useSession } from 'next-auth/react';
+import Card from '@/components/ui/Card';
+import Button from '@/components/ui/Button';
+import Badge from '@/components/ui/Badge';
+
+interface VocabularyWord {
+  id: string;
+  word: string;
+  meaning: string;
+  category: 'travel' | 'smalltalk' | 'business';
+  subcategory: string;
+  pronunciation: string;
+  example: string;
+  translation: string;
+  difficulty: 'basic' | 'intermediate' | 'advanced';
+  createdAt: number;
+  nextReviewDate: number;
+  interval: number;
+  easinessFactor: number;
+  correctCount: number;
+  incorrectCount: number;
+  lastReviewed?: number;
+}
+
+interface StudyProgress {
+  totalWords: number;
+  todayStudied: number;
+  dueCount: number;
+  studyStreak: number;
+  categoryProgress: {
+    travel: number;
+    smalltalk: number;
+    business: number;
+  };
+}
+
+interface StudySession {
+  word: VocabularyWord;
+  userAnswer: string;
+  isCorrect: boolean;
+  timeSpent: number;
+}
+
+type StudyMode = 'dashboard' | 'category_selection' | 'study' | 'review' | 'results';
+
+// Vocabulary categories with subcategories
+const VOCABULARY_CATEGORIES = {
+  travel: {
+    name: 'ì—¬í–‰ ì˜ì–´',
+    icon: 'âœˆï¸',
+    color: 'blue',
+    subcategories: {
+      airport: 'ê³µí•­',
+      hotel: 'í˜¸í…”',
+      restaurant: 'ë ˆìŠ¤í† ë‘',
+      shopping: 'ì‡¼í•‘',
+      transportation: 'êµí†µ',
+      emergency: 'ì‘ê¸‰ìƒí™©'
+    }
+  },
+  smalltalk: {
+    name: 'ì¼ìƒ ëŒ€í™”',
+    icon: 'ğŸ’¬',
+    color: 'green',
+    subcategories: {
+      weather: 'ë‚ ì”¨',
+      hobbies: 'ì·¨ë¯¸',
+      work: 'ì§ì¥',
+      family: 'ê°€ì¡±',
+      food: 'ìŒì‹',
+      entertainment: 'ì—”í„°í…Œì¸ë¨¼íŠ¸'
+    }
+  },
+  business: {
+    name: 'ë¹„ì¦ˆë‹ˆìŠ¤ ì˜ì–´',
+    icon: 'ğŸ’¼',
+    color: 'purple',
+    subcategories: {
+      meetings: 'íšŒì˜',
+      presentations: 'ë°œí‘œ',
+      emails: 'ì´ë©”ì¼',
+      negotiations: 'í˜‘ìƒ',
+      networking: 'ë„¤íŠ¸ì›Œí‚¹',
+      reports: 'ë³´ê³ ì„œ'
+    }
+  }
+};
+
+export function ChristineVocabulary() {
+  const { data: session } = useSession();
+  const [mode, setMode] = useState<StudyMode>('dashboard');
+  const [selectedCategory, setSelectedCategory] = useState<keyof typeof VOCABULARY_CATEGORIES | null>(null);
+  const [selectedSubcategory, setSelectedSubcategory] = useState<string | null>(null);
+  const [studyWords, setStudyWords] = useState<VocabularyWord[]>([]);
+  const [currentWordIndex, setCurrentWordIndex] = useState(0);
+  const [userAnswer, setUserAnswer] = useState('');
+  const [showAnswer, setShowAnswer] = useState(false);
+  const [studySession, setStudySession] = useState<StudySession[]>([]);
+  const [progress, setProgress] = useState<StudyProgress | null>(null);
+  const [loading, setLoading] = useState(false);
+  const [error, setError] = useState<string | null>(null);
+  const [sessionStartTime, setSessionStartTime] = useState(0);
+
+  const userId = session?.user?.name || 'anonymous';
+
+  // Load study progress
+  const loadProgress = useCallback(async () => {
+    try {
+      const response = await fetch(`/api/influencers/christine/vocabulary?action=progress&userId=${userId}`);
+      const data = await response.json();
+
+      if (data.success) {
+        setProgress(data.progress);
+      }
+    } catch (err) {
+      console.error('Progress loading error:', err);
+    }
+  }, [userId]);
+
+  // Load study words for selected category
+  const loadStudyWords = async (category: string, subcategory?: string, studyType: 'new' | 'review' = 'new') => {
+    try {
+      setLoading(true);
+      setError(null);
+
+      const response = await fetch('/api/influencers/christine/vocabulary', {
+        method: 'POST',
+        headers: {
+          'Content-Type': 'application/json',
+        },
+        body: JSON.stringify({
+          action: studyType === 'new' ? 'generate_study_words' : 'get_due_words',
+          userId,
+          category,
+          subcategory,
+          count: 10
+        }),
+      });
+
+      const data = await response.json();
+
+      if (data.success) {
+        setStudyWords(data.words || []);
+        setMode('study');
+        setCurrentWordIndex(0);
+        setUserAnswer('');
+        setShowAnswer(false);
+        setStudySession([]);
+        setSessionStartTime(Date.now());
+      } else {
+        setError(data.error || 'Failed to load words');
+      }
+    } catch (err) {
+      setError('ë‹¨ì–´ ë¡œë”© ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  // Submit answer and get feedback
+  const submitAnswer = async () => {
+    if (!userAnswer.trim() || !studyWords[currentWordIndex]) return;
+
+    const currentWord = studyWords[currentWordIndex];
+    const startTime = sessionStartTime;
+    const timeSpent = Date.now() - startTime;
+
+    try {
+      setLoading(true);
+
+      const response = await fetch('/api/influencers/christine/vocabulary', {
+        method: 'POST',
+        headers: {
+          'Content-Type': 'application/json',
+        },
+        body: JSON.stringify({
+          action: 'check_answer',
+          userId,
+          wordId: currentWord.id,
+          userAnswer: userAnswer.trim(),
+          timeSpent
+        }),
+      });
+
+      const data = await response.json();
+
+      if (data.success) {
+        const sessionItem: StudySession = {
+          word: currentWord,
+          userAnswer: userAnswer.trim(),
+          isCorrect: data.isCorrect,
+          timeSpent
+        };
+
+        setStudySession(prev => [...prev, sessionItem]);
+        setShowAnswer(true);
+
+        // Update word's SRS data
+        if (data.updatedWord) {
+          setStudyWords(prev =>
+            prev.map(w => w.id === currentWord.id ? data.updatedWord : w)
+          );
+        }
+      } else {
+        setError(data.error || 'Failed to check answer');
+      }
+    } catch (err) {
+      setError('ë‹µë³€ í™•ì¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  // Move to next word
+  const nextWord = () => {
+    if (currentWordIndex < studyWords.length - 1) {
+      setCurrentWordIndex(currentWordIndex + 1);
+      setUserAnswer('');
+      setShowAnswer(false);
+      setSessionStartTime(Date.now());
+    } else {
+      // Study session completed
+      setMode('results');
+    }
+  };
+
+  // Load initial progress
+  useEffect(() => {
+    if (session) {
+      loadProgress();
+    }
+  }, [session, loadProgress]);
+
+  // Render dashboard
+  if (mode === 'dashboard') {
+    return (
+      <div className="space-y-6">
+        {/* Header */}
+        <Card className="p-6" glass={false}>
+          <div className="text-center space-y-4">
+            <div className="w-20 h-20 mx-auto bg-gradient-to-br from-purple-500/20 to-pink-500/20 rounded-full flex items-center justify-center">
+              <span className="text-4xl">ğŸ“š</span>
+            </div>
+            <h2 className="text-2xl font-bold text-[var(--color-text-primary)]">
+              Christine ì‹¤ìš© ë‹¨ì–´ ì•”ê¸°
+            </h2>
+            <p className="text-[var(--color-text-secondary)] max-w-2xl mx-auto">
+              SRS(ê°„ê²© ë°˜ë³µ) ì‹œìŠ¤í…œìœ¼ë¡œ íš¨ìœ¨ì ì¸ ë‹¨ì–´ ì•”ê¸°!
+              ì‹¤ì œ ìƒí™©ì—ì„œ ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì‹¤ìš©ì ì¸ ë‹¨ì–´ë“¤ì„ ì²´ê³„ì ìœ¼ë¡œ í•™ìŠµí•˜ì„¸ìš”.
+            </p>
+            <div className="flex flex-wrap justify-center gap-2">
+              <Badge variant="primary" size="sm">SRS ì•Œê³ ë¦¬ì¦˜</Badge>
+              <Badge variant="success" size="sm">ì‹¤ìš© ì¤‘ì‹¬</Badge>
+              <Badge variant="warning" size="sm">ìƒí™©ë³„ ë¶„ë¥˜</Badge>
+            </div>
+          </div>
+        </Card>
+
+        {/* Progress Overview */}
+        {progress && (
+          <Card className="p-6" glass={false}>
+            <h3 className="text-lg font-semibold text-[var(--color-text-primary)] mb-4">
+              ğŸ“Š í•™ìŠµ í˜„í™©
+            </h3>
+            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
+              <div className="text-center p-4 bg-[var(--color-bg-secondary)] rounded-lg">
+                <div className="text-2xl font-bold text-blue-600">{progress.totalWords}</div>
+                <div className="text-sm text-[var(--color-text-secondary)]">ì´ í•™ìŠµ ë‹¨ì–´</div>
+              </div>
+              <div className="text-center p-4 bg-[var(--color-bg-secondary)] rounded-lg">
+                <div className="text-2xl font-bold text-green-600">{progress.todayStudied}</div>
+                <div className="text-sm text-[var(--color-text-secondary)]">ì˜¤ëŠ˜ í•™ìŠµ</div>
+              </div>
+              <div className="text-center p-4 bg-[var(--color-bg-secondary)] rounded-lg">
+                <div className="text-2xl font-bold text-orange-600">{progress.dueCount}</div>
+                <div className="text-sm text-[var(--color-text-secondary)]">ë³µìŠµ ì˜ˆì •</div>
+              </div>
+              <div className="text-center p-4 bg-[var(--color-bg-secondary)] rounded-lg">
+                <div className="text-2xl font-bold text-purple-600">{progress.studyStreak}</div>
+                <div className="text-sm text-[var(--color-text-secondary)]">ì—°ì† í•™ìŠµì¼</div>
+              </div>
+            </div>
+          </Card>
+        )}
+
+        {/* Quick Actions */}
+        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
+          {/* New Words */}
+          <Card className="p-6" glass={false}>
+            <h3 className="text-lg font-semibold text-[var(--color-text-primary)] mb-4">
+              ğŸŒŸ ìƒˆë¡œìš´ ë‹¨ì–´ í•™ìŠµ
+            </h3>
+            <p className="text-[var(--color-text-secondary)] mb-4">
+              ìƒí™©ë³„ë¡œ ë¶„ë¥˜ëœ ì‹¤ìš©ì ì¸ ìƒˆ ë‹¨ì–´ë“¤ì„ í•™ìŠµí•´ë³´ì„¸ìš”.
+            </p>
+            <Button
+              onClick={() => setMode('category_selection')}
+              variant="primary"
+              className="w-full"
+            >
+              ğŸ“ ìƒˆ ë‹¨ì–´ í•™ìŠµ ì‹œì‘
+            </Button>
+          </Card>
+
+          {/* Review */}
+          <Card className="p-6" glass={false}>
+            <h3 className="text-lg font-semibold text-[var(--color-text-primary)] mb-4">
+              ğŸ”„ ë³µìŠµí•˜ê¸°
+            </h3>
+            {progress && progress.dueCount > 0 ? (
+              <div className="space-y-4">
+                <p className="text-[var(--color-text-secondary)]">
+                  {progress.dueCount}ê°œì˜ ë‹¨ì–´ê°€ ë³µìŠµì„ ê¸°ë‹¤ë¦¬ê³  ìˆìŠµë‹ˆë‹¤.
+                </p>
+                <Button
+                  onClick={() => loadStudyWords('all', undefined, 'review')}
+                  variant="outline"
+                  className="w-full bg-yellow-50 border-yellow-300 hover:bg-yellow-100"
+                >
+                  ğŸ“ ë³µìŠµ ì‹œì‘í•˜ê¸°
+                </Button>
+              </div>
+            ) : (
+              <div className="space-y-4">
+                <p className="text-[var(--color-text-secondary)]">
+                  ë³µìŠµí•  ë‹¨ì–´ê°€ ì—†ìŠµë‹ˆë‹¤. í›Œë¥­í•´ìš”! ğŸ‰
+                </p>
+                <div className="text-center py-4">
+                  <span className="text-3xl">âœ…</span>
+                </div>
+              </div>
+            )}
+          </Card>
+        </div>
+
+        {/* Category Progress */}
+        {progress && (
+          <Card className="p-6" glass={false}>
+            <h3 className="text-lg font-semibold text-[var(--color-text-primary)] mb-4">
+              ğŸ“ˆ ì¹´í…Œê³ ë¦¬ë³„ ì§„ë„
+            </h3>
+            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
+              {Object.entries(VOCABULARY_CATEGORIES).map(([categoryKey, categoryData]) => {
+                const categoryProgress = progress.categoryProgress[categoryKey as keyof typeof progress.categoryProgress] || 0;
+                return (
+                  <div
+                    key={categoryKey}
+                    className={`p-4 rounded-lg border border-${categoryData.color}-200 dark:border-${categoryData.color}-800 bg-${categoryData.color}-50 dark:bg-${categoryData.color}-900/20`}
+                  >
+                    <div className="flex items-center gap-2 mb-2">
+                      <span className="text-xl">{categoryData.icon}</span>
+                      <h4 className={`font-medium text-${categoryData.color}-700 dark:text-${categoryData.color}-200`}>
+                        {categoryData.name}
+                      </h4>
+                    </div>
+                    <div className={`text-2xl font-bold text-${categoryData.color}-600 dark:text-${categoryData.color}-300`}>
+                      {categoryProgress}ê°œ
+                    </div>
+                    <div className={`text-sm text-${categoryData.color}-600 dark:text-${categoryData.color}-400`}>
+                      í•™ìŠµ ì™„ë£Œ
+                    </div>
+                  </div>
+                );
+              })}
+            </div>
+          </Card>
+        )}
+      </div>
+    );
+  }
+
+  // Render category selection
+  if (mode === 'category_selection') {
+    return (
+      <div className="space-y-6">
+        <Card className="p-6" glass={false}>
+          <div className="flex justify-between items-center mb-4">
+            <h3 className="text-xl font-semibold text-[var(--color-text-primary)]">
+              ì¹´í…Œê³ ë¦¬ ì„ íƒ
+            </h3>
+            <Button
+              onClick={() => setMode('dashboard')}
+              variant="outline"
+              size="sm"
+            >
+              â† ëŒ€ì‹œë³´ë“œë¡œ
+            </Button>
+          </div>
+          <p className="text-[var(--color-text-secondary)] mb-6">
+            í•™ìŠµí•˜ê³  ì‹¶ì€ ë¶„ì•¼ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”. ê° ë¶„ì•¼ë³„ë¡œ ì‹¤ë¬´ì—ì„œ ìì£¼ ì‚¬ìš©ë˜ëŠ” ë‹¨ì–´ë“¤ì„ ì¤€ë¹„í–ˆìŠµë‹ˆë‹¤.
+          </p>
+
+          <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
+            {Object.entries(VOCABULARY_CATEGORIES).map(([categoryKey, categoryData]) => (
+              <Card
+                key={categoryKey}
+                className={`p-6 cursor-pointer transition-all duration-200 ${
+                  selectedCategory === categoryKey
+                    ? `ring-2 ring-${categoryData.color}-500 bg-${categoryData.color}-50 dark:bg-${categoryData.color}-900/20`
+                    : 'hover:shadow-md'
+                }`}
+                glass={false}
+                onClick={() => {
+                  setSelectedCategory(categoryKey as keyof typeof VOCABULARY_CATEGORIES);
+                  setSelectedSubcategory(null);
+                }}
+              >
+                <div className="text-center space-y-4">
+                  <div className="text-4xl">{categoryData.icon}</div>
+                  <h4 className="text-lg font-semibold text-[var(--color-text-primary)]">
+                    {categoryData.name}
+                  </h4>
+                  <div className="flex flex-wrap gap-1 justify-center">
+                    {Object.values(categoryData.subcategories).map((sub, idx) => (
+                      <Badge key={idx} variant="info" size="sm">
+                        {sub}
+                      </Badge>
+                    ))}
+                  </div>
+                </div>
+              </Card>
+            ))}
+          </div>
+
+          {/* Subcategory Selection */}
+          {selectedCategory && (
+            <Card className="p-6 mt-6" glass={false}>
+              <h4 className="text-lg font-semibold text-[var(--color-text-primary)] mb-4">
+                ì„¸ë¶€ ë¶„ì•¼ ì„ íƒ (ì„ íƒì‚¬í•­)
+              </h4>
+              <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-3">
+                <Button
+                  variant={selectedSubcategory === null ? 'primary' : 'outline'}
+                  size="sm"
+                  onClick={() => setSelectedSubcategory(null)}
+                  className="text-sm"
+                >
+                  ì „ì²´
+                </Button>
+                {Object.entries(VOCABULARY_CATEGORIES[selectedCategory].subcategories).map(([subKey, subName]) => (
+                  <Button
+                    key={subKey}
+                    variant={selectedSubcategory === subKey ? 'primary' : 'outline'}
+                    size="sm"
+                    onClick={() => setSelectedSubcategory(subKey)}
+                    className="text-sm"
+                  >
+                    {subName}
+                  </Button>
+                ))}
+              </div>
+            </Card>
+          )}
+
+          {/* Start Button */}
+          {selectedCategory && (
+            <Card className="p-6 text-center" glass={false}>
+              <Button
+                onClick={() => loadStudyWords(selectedCategory, selectedSubcategory || undefined)}
+                disabled={loading}
+                variant="primary"
+                size="lg"
+              >
+                {loading ? 'AI ë‹¨ì–´ ìƒì„± ì¤‘...' : 'ğŸš€ ë‹¨ì–´ í•™ìŠµ ì‹œì‘í•˜ê¸°'}
+              </Button>
+            </Card>
+          )}
+        </Card>
+
+        {error && (
+          <Card className="p-4 bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800">
+            <p className="text-red-800 dark:text-red-200 text-sm">{error}</p>
+          </Card>
+        )}
+      </div>
+    );
+  }
+
+  // Render study session
+  if (mode === 'study' && studyWords.length > 0) {
+    const currentWord = studyWords[currentWordIndex];
+    const progressPercent = Math.round(((currentWordIndex + 1) / studyWords.length) * 100);
+
+    return (
+      <div className="space-y-6">
+        {/* Progress Header */}
+        <Card className="p-4" glass={false}>
+          <div className="flex justify-between items-center mb-2">
+            <h3 className="text-lg font-semibold text-[var(--color-text-primary)]">
+              ğŸ“š ë‹¨ì–´ í•™ìŠµ ì§„í–‰ ì¤‘
+            </h3>
+            <Button
+              onClick={() => setMode('dashboard')}
+              variant="outline"
+              size="sm"
+            >
+              ëŒ€ì‹œë³´ë“œë¡œ
+            </Button>
+          </div>
+          <div className="w-full bg-[var(--color-bg-tertiary)] rounded-full h-2 mb-2">
+            <div
+              className="bg-gradient-to-r from-purple-500 to-pink-500 h-2 rounded-full transition-all duration-300"
+              style={{ width: `${progressPercent}%` }}
+            />
+          </div>
+          <p className="text-sm text-[var(--color-text-secondary)]">
+            {currentWordIndex + 1} / {studyWords.length} ({progressPercent}% ì™„ë£Œ)
+          </p>
+        </Card>
+
+        {/* Word Card */}
+        <Card className="p-8 text-center" glass={false}>
+          <div className="space-y-6">
+            {/* Category Badge */}
+            <div className="flex justify-center">
+              <Badge variant="primary" size="sm">
+                {currentWord.category === 'travel' ? 'ì—¬í–‰' :
+                 currentWord.category === 'smalltalk' ? 'ì¼ìƒ ëŒ€í™”' : 'ë¹„ì¦ˆë‹ˆìŠ¤'} â€¢ {currentWord.subcategory}
+              </Badge>
+            </div>
+
+            {/* Word */}
+            <div>
+              <h2 className="text-4xl font-bold text-[var(--color-text-primary)] mb-2">
+                {currentWord.word}
+              </h2>
+              <p className="text-lg text-[var(--color-text-secondary)]">
+                [{currentWord.pronunciation}]
+              </p>
+            </div>
+
+            {/* Example Sentence */}
+            <div className="bg-[var(--color-bg-secondary)] p-4 rounded-lg">
+              <p className="text-lg font-medium text-[var(--color-text-primary)] mb-2">
+                "{currentWord.example}"
+              </p>
+              <p className="text-sm text-[var(--color-text-tertiary)]">
+                {currentWord.translation}
+              </p>
+            </div>
+
+            {!showAnswer ? (
+              // Answer Input
+              <div className="space-y-4">
+                <h4 className="font-medium text-[var(--color-text-primary)]">
+                  âœï¸ ì´ ë‹¨ì–´ì˜ ëœ»ì„ í•œê¸€ë¡œ ì…ë ¥í•˜ì„¸ìš”:
+                </h4>
+                <input
+                  type="text"
+                  value={userAnswer}
+                  onChange={(e) => setUserAnswer(e.target.value)}
+                  placeholder="ë‹¨ì–´ì˜ ëœ»ì„ ì…ë ¥í•˜ì„¸ìš”..."
+                  className="w-full p-4 border rounded-lg text-center bg-[var(--color-bg-primary)] text-lg"
+                  disabled={loading}
+                  onKeyPress={(e) => {
+                    if (e.key === 'Enter') {
+                      submitAnswer();
+                    }
+                  }}
+                />
+                <Button
+                  onClick={submitAnswer}
+                  disabled={loading || !userAnswer.trim()}
+                  variant="primary"
+                  size="lg"
+                >
+                  {loading ? 'í™•ì¸ ì¤‘...' : 'âœ… ë‹µì•ˆ í™•ì¸'}
+                </Button>
+              </div>
+            ) : (
+              // Answer Result
+              <div className="space-y-4">
+                <div className={`p-4 rounded-lg ${
+                  studySession[studySession.length - 1]?.isCorrect
+                    ? 'bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800'
+                    : 'bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800'
+                }`}>
+                  <div className="text-center">
+                    <h4 className={`text-xl font-semibold mb-2 ${
+                      studySession[studySession.length - 1]?.isCorrect
+                        ? 'text-green-700 dark:text-green-200'
+                        : 'text-red-700 dark:text-red-200'
+                    }`}>
+                      {studySession[studySession.length - 1]?.isCorrect ? 'ì •ë‹µ! ğŸ‰' : 'í‹€ë ¸ìŠµë‹ˆë‹¤ ğŸ˜…'}
+                    </h4>
+                    <p className="text-lg font-medium text-[var(--color-text-primary)] mb-2">
+                      ì •ë‹µ: {currentWord.meaning}
+                    </p>
+                    <p className={`text-sm ${
+                      studySession[studySession.length - 1]?.isCorrect
+                        ? 'text-green-600 dark:text-green-300'
+                        : 'text-red-600 dark:text-red-300'
+                    }`}>
+                      ì…ë ¥í•œ ë‹µ: {userAnswer}
+                    </p>
+                  </div>
+                </div>
+
+                <Button
+                  onClick={nextWord}
+                  variant="primary"
+                  size="lg"
+                >
+                  {currentWordIndex < studyWords.length - 1 ? 'ë‹¤ìŒ ë‹¨ì–´ â†’' : 'ì™„ë£Œ! ê²°ê³¼ ë³´ê¸° ğŸ‰'}
+                </Button>
+              </div>
+            )}
+          </div>
+        </Card>
+      </div>
+    );
+  }
+
+  // Render results
+  if (mode === 'results') {
+    const correctAnswers = studySession.filter(s => s.isCorrect).length;
+    const totalAnswers = studySession.length;
+    const accuracy = totalAnswers > 0 ? Math.round((correctAnswers / totalAnswers) * 100) : 0;
+
+    return (
+      <Card className="p-8 text-center" glass={false}>
+        <div className="space-y-6">
+          <span className="text-6xl">ğŸ‰</span>
+          <h2 className="text-2xl font-bold text-[var(--color-text-primary)]">
+            ë‹¨ì–´ í•™ìŠµ ì™„ë£Œ!
+          </h2>
+
+          {/* Score */}
+          <div className="bg-gradient-to-br from-purple-50 to-pink-50 dark:from-purple-900/20 dark:to-pink-900/20 p-6 rounded-lg">
+            <h3 className="text-lg font-semibold text-[var(--color-text-primary)] mb-2">
+              ğŸ“Š í•™ìŠµ ê²°ê³¼
+            </h3>
+            <p className="text-4xl font-bold text-purple-600 dark:text-purple-400 mb-2">
+              {correctAnswers}/{totalAnswers}
+            </p>
+            <p className="text-xl font-semibold text-purple-700 dark:text-purple-300 mb-1">
+              ì •í™•ë„: {accuracy}%
+            </p>
+            <p className="text-sm text-[var(--color-text-secondary)]">
+              ì´ í•™ìŠµ ì‹œê°„: {Math.round(studySession.reduce((sum, s) => sum + s.timeSpent, 0) / 1000)}ì´ˆ
+            </p>
+          </div>
+
+          {/* Detailed Results */}
+          <div className="max-h-60 overflow-y-auto">
+            <div className="space-y-2">
+              {studySession.map((session, index) => (
+                <div
+                  key={index}
+                  className={`flex items-center justify-between p-3 rounded-lg ${
+                    session.isCorrect
+                      ? 'bg-green-50 dark:bg-green-900/20'
+                      : 'bg-red-50 dark:bg-red-900/20'
+                  }`}
+                >
+                  <div className="flex items-center gap-3">
+                    <span className={`text-lg ${session.isCorrect ? 'âœ…' : 'âŒ'}`}>
+                      {session.isCorrect ? 'âœ…' : 'âŒ'}
+                    </span>
+                    <div className="text-left">
+                      <p className="font-medium text-[var(--color-text-primary)]">
+                        {session.word.word}
+                      </p>
+                      <p className="text-sm text-[var(--color-text-secondary)]">
+                        ì •ë‹µ: {session.word.meaning} | ì…ë ¥: {session.userAnswer}
+                      </p>
+                    </div>
+                  </div>
+                  <p className="text-xs text-[var(--color-text-tertiary)]">
+                    {Math.round(session.timeSpent / 1000)}ì´ˆ
+                  </p>
+                </div>
+              ))}
+            </div>
+          </div>
+
+          {/* Action Buttons */}
+          <div className="flex flex-col sm:flex-row gap-4 justify-center">
+            <Button
+              onClick={() => setMode('category_selection')}
+              variant="outline"
+            >
+              ë‹¤ë¥¸ ì¹´í…Œê³ ë¦¬ í•™ìŠµ
+            </Button>
+            <Button
+              onClick={() => setMode('dashboard')}
+              variant="primary"
+            >
+              ëŒ€ì‹œë³´ë“œë¡œ ëŒì•„ê°€ê¸°
+            </Button>
+          </div>
+        </div>
+      </Card>
+    );
+  }
+
+  return (
+    <div className="text-center py-8">
+      <div className="text-[var(--color-text-primary)]">ë¡œë”© ì¤‘...</div>
+    </div>
+  );
+}
\ No newline at end of file
diff --git a/components/christine/CorePhrasePatternPractice.tsx b/components/christine/CorePhrasePatternPractice.tsx
new file mode 100644
index 0000000..9caeb47
--- /dev/null
+++ b/components/christine/CorePhrasePatternPractice.tsx
@@ -0,0 +1,662 @@
+'use client';
+
+/**
+ * Core Phrase Pattern Practice Component
+ *
+ * Christineì˜ í•µì‹¬ íŒ¨í„´ ì—°ìŠµ ê¸°ëŠ¥:
+ * - 3ê°œì›”ì°¨ ì»¤ë¦¬í˜ëŸ¼ ê¸°ë°˜ (ì—¬í–‰/ìŠ¤ëª°í† í¬/ë¹„ì¦ˆë‹ˆìŠ¤)
+ * - AI ìë™ ë³€í˜• ë¬¸ì œ ìƒì„±
+ * - ë¹ˆì¹¸ ì±„ìš°ê¸° + ë¬¸ì¥ ì™„ì„±
+ * - ë‹¨ê³„ë³„ ë‚œì´ë„ ì¡°ì ˆ
+ */
+
+import React, { useState, useEffect, useCallback } from 'react';
+import { useSession } from 'next-auth/react';
+import Card from '@/components/ui/Card';
+import Button from '@/components/ui/Button';
+import Badge from '@/components/ui/Badge';
+
+// Core Phrase Data Structure
+const CORE_PHRASES = {
+  '1ê°œì›”ì°¨': {
+    name: 'ì—¬í–‰ (Travel)',
+    icon: 'âœˆï¸',
+    weeks: {
+      '1ì£¼ì°¨': {
+        name: 'ê³µí•­ (Airport)',
+        icon: 'ğŸ›«',
+        phrases: [
+          "I'd like to check in.",
+          "Can I get a window seat?",
+          "How many bags can I check in?",
+          "Do I need to pay for overweight luggage?",
+          "Where is gate 12?"
+        ]
+      },
+      '2ì£¼ì°¨': {
+        name: 'ê¸°ë‚´ (On the Plane)',
+        icon: 'âœˆï¸',
+        phrases: [
+          "Could I get some water?",
+          "Can I have a blanket?",
+          "Excuse me, that's my seat.",
+          "Can we switch seats?",
+          "How long is the flight?"
+        ]
+      },
+      '3ì£¼ì°¨': {
+        name: 'í˜¸í…” (Hotel)',
+        icon: 'ğŸ¨',
+        phrases: [
+          "I have a reservation.",
+          "Can I check out late?",
+          "Could I get extra towels?",
+          "The air conditioner isn't working.",
+          "Is breakfast included?"
+        ]
+      },
+      '4ì£¼ì°¨': {
+        name: 'ì¹´í˜Â·ë ˆìŠ¤í† ë‘Â·ì‡¼í•‘',
+        icon: 'ğŸ›ï¸',
+        phrases: [
+          "Can I get an iced latte?",
+          "Do you have a table for two?",
+          "What do you recommend?",
+          "How much is this?",
+          "Do you have it in another size?"
+        ]
+      }
+    }
+  },
+  '2ê°œì›”ì°¨': {
+    name: 'ìŠ¤ëª°í† í¬ (Small Talk)',
+    icon: 'ğŸ’¬',
+    weeks: {
+      '1ì£¼ì°¨': {
+        name: 'ë‚ ì”¨ (Weather)',
+        icon: 'ğŸŒ¤ï¸',
+        phrases: [
+          "It's chilly today.",
+          "Feels like autumn already.",
+          "This weather makes me sleepy.",
+          "It's perfect for a walk.",
+          "You must be cold."
+        ]
+      },
+      '2ì£¼ì°¨': {
+        name: 'ê·¼í™© (Catching Up)',
+        icon: 'ğŸ‘¥',
+        phrases: [
+          "I've been busy with work.",
+          "I just got back from a trip.",
+          "My son started school.",
+          "I've been working on my cooking.",
+          "Nothing much, same as usual."
+        ]
+      },
+      '3ì£¼ì°¨': {
+        name: 'ì¹­ì°¬Â·ê³µê° (Compliments & Empathy)',
+        icon: 'ğŸ‘',
+        phrases: [
+          "I love your outfit.",
+          "That's impressive!",
+          "That sounds fun.",
+          "I know what you mean.",
+          "No way!"
+        ]
+      },
+      '4ì£¼ì°¨': {
+        name: 'ëŒ€í™” ì´ì–´ê°€ê¸°Â·ë§ˆë¬´ë¦¬ (Conversation Flow)',
+        icon: 'ğŸ”„',
+        phrases: [
+          "By the way, â€¦",
+          "Speaking of that, â€¦",
+          "It was nice chatting.",
+          "I'll let you go now.",
+          "Let's grab coffee sometime."
+        ]
+      }
+    }
+  },
+  '3ê°œì›”ì°¨': {
+    name: 'íšŒì‚¬ (Work & Business)',
+    icon: 'ğŸ’¼',
+    weeks: {
+      '1ì£¼ì°¨': {
+        name: 'íšŒì˜ ì‹œì‘Â·ë™ì˜/ë¹„ë™ì˜',
+        icon: 'ğŸ¤',
+        phrases: [
+          "Shall we get started?",
+          "I agree with you.",
+          "I'm not sure about that.",
+          "Can we try another option?",
+          "Let's hear from others."
+        ]
+      },
+      '2ì£¼ì°¨': {
+        name: 'ì˜ê²¬ ì œì‹œÂ·ëŒ€ì•ˆ ì œì•ˆ',
+        icon: 'ğŸ’¡',
+        phrases: [
+          "In my opinion, â€¦",
+          "I suggest we â€¦",
+          "What if we â€¦?",
+          "That might work.",
+          "We need more data."
+        ]
+      },
+      '3ì£¼ì°¨': {
+        name: 'ì¼ì •Â·ì‹œê°„ í˜‘ì˜',
+        icon: 'ğŸ“…',
+        phrases: [
+          "When is the deadline?",
+          "Can we move the meeting?",
+          "Let's set a timeline.",
+          "I'm available on Monday.",
+          "Does that work for you?"
+        ]
+      },
+      '4ì£¼ì°¨': {
+        name: 'ë„¤íŠ¸ì›Œí‚¹Â·ì¸ì‚¬',
+        icon: 'ğŸ¤',
+        phrases: [
+          "Nice to meet you.",
+          "What do you do?",
+          "It was great talking with you.",
+          "Let's keep in touch.",
+          "See you at the next meeting."
+        ]
+      }
+    }
+  }
+};
+
+interface PracticeQuestion {
+  id: string;
+  type: 'fill_blank' | 'complete_sentence' | 'variation';
+  originalPhrase: string;
+  question: string;
+  answer: string;
+  options?: string[];
+  explanation?: string;
+}
+
+interface PracticeProgress {
+  monthKey: string;
+  weekKey: string;
+  completedQuestions: string[];
+  score: number;
+}
+
+type PracticeMode = 'selection' | 'practice' | 'results';
+
+export function CorePhrasePatternPractice() {
+  const { data: session } = useSession();
+  const [mode, setMode] = useState<PracticeMode>('selection');
+  const [selectedMonth, setSelectedMonth] = useState<string | null>(null);
+  const [selectedWeek, setSelectedWeek] = useState<string | null>(null);
+  const [questions, setQuestions] = useState<PracticeQuestion[]>([]);
+  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
+  const [userAnswers, setUserAnswers] = useState<{[key: string]: string}>({});
+  const [loading, setLoading] = useState(false);
+  const [error, setError] = useState<string | null>(null);
+  const [progress, setProgress] = useState<PracticeProgress | null>(null);
+
+  const userId = session?.user?.name || 'anonymous';
+
+  // Load practice progress
+  const loadProgress = useCallback(async () => {
+    if (!selectedMonth || !selectedWeek) return;
+
+    try {
+      const response = await fetch(
+        `/api/influencers/christine/core-phrase?action=progress&userId=${userId}&month=${selectedMonth}&week=${selectedWeek}`
+      );
+      const data = await response.json();
+
+      if (data.success && data.progress) {
+        setProgress(data.progress);
+      }
+    } catch (err) {
+      console.error('Progress loading error:', err);
+    }
+  }, [userId, selectedMonth, selectedWeek]);
+
+  // Generate practice questions
+  const generateQuestions = async () => {
+    if (!selectedMonth || !selectedWeek) return;
+
+    try {
+      setLoading(true);
+      setError(null);
+
+      const monthData = CORE_PHRASES[selectedMonth as keyof typeof CORE_PHRASES];
+      const weekData = monthData.weeks[selectedWeek as keyof typeof monthData.weeks];
+      const phrases = weekData.phrases;
+
+      const response = await fetch('/api/influencers/christine/core-phrase', {
+        method: 'POST',
+        headers: {
+          'Content-Type': 'application/json',
+        },
+        body: JSON.stringify({
+          action: 'generate_questions',
+          userId,
+          month: selectedMonth,
+          week: selectedWeek,
+          phrases,
+          count: 10
+        }),
+      });
+
+      const data = await response.json();
+
+      if (data.success) {
+        setQuestions(data.questions || []);
+        setMode('practice');
+        setCurrentQuestionIndex(0);
+        setUserAnswers({});
+      } else {
+        setError(data.error || 'Failed to generate questions');
+      }
+    } catch (err) {
+      setError('ë¬¸ì œ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  // Handle answer selection
+  const handleAnswer = (questionId: string, answer: string) => {
+    setUserAnswers(prev => ({
+      ...prev,
+      [questionId]: answer
+    }));
+  };
+
+  // Move to next question
+  const nextQuestion = () => {
+    if (currentQuestionIndex < questions.length - 1) {
+      setCurrentQuestionIndex(currentQuestionIndex + 1);
+    } else {
+      // All questions completed - show results
+      calculateAndShowResults();
+    }
+  };
+
+  // Calculate results
+  const calculateAndShowResults = async () => {
+    try {
+      const response = await fetch('/api/influencers/christine/core-phrase', {
+        method: 'POST',
+        headers: {
+          'Content-Type': 'application/json',
+        },
+        body: JSON.stringify({
+          action: 'calculate_results',
+          userId,
+          month: selectedMonth,
+          week: selectedWeek,
+          questions,
+          userAnswers
+        }),
+      });
+
+      const data = await response.json();
+
+      if (data.success) {
+        setProgress(data.progress);
+        setMode('results');
+      } else {
+        setError(data.error || 'Failed to calculate results');
+      }
+    } catch (err) {
+      setError('ê²°ê³¼ ê³„ì‚° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
+    }
+  };
+
+  // Reset to selection
+  const resetToSelection = () => {
+    setMode('selection');
+    setSelectedMonth(null);
+    setSelectedWeek(null);
+    setQuestions([]);
+    setCurrentQuestionIndex(0);
+    setUserAnswers({});
+    setError(null);
+    setProgress(null);
+  };
+
+  // Load progress when selection changes
+  useEffect(() => {
+    if (selectedMonth && selectedWeek) {
+      loadProgress();
+    }
+  }, [selectedMonth, selectedWeek, loadProgress]);
+
+  // Render month/week selection
+  if (mode === 'selection') {
+    return (
+      <div className="space-y-6">
+        {/* Header */}
+        <Card className="p-6" glass={false}>
+          <div className="text-center space-y-4">
+            <div className="w-20 h-20 mx-auto bg-gradient-to-br from-blue-500/20 to-purple-500/20 rounded-full flex items-center justify-center">
+              <span className="text-4xl">ğŸ“</span>
+            </div>
+            <h2 className="text-2xl font-bold text-[var(--color-text-primary)]">
+              Core Phrase íŒ¨í„´ ì—°ìŠµ
+            </h2>
+            <p className="text-[var(--color-text-secondary)] max-w-2xl mx-auto">
+              Christineì˜ ì²´ê³„ì ì¸ 3ê°œì›” ì»¤ë¦¬í˜ëŸ¼ìœ¼ë¡œ ì‹¤ì „ ì˜ì–´ íŒ¨í„´ì„ ë§ˆìŠ¤í„°í•˜ì„¸ìš”!
+              ê° ìƒí™©ë³„ í•µì‹¬ í‘œí˜„ì„ ë‹¤ì–‘í•œ ë°©ì‹ìœ¼ë¡œ ì—°ìŠµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
+            </p>
+          </div>
+        </Card>
+
+        {/* Month Selection */}
+        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
+          {Object.entries(CORE_PHRASES).map(([monthKey, monthData]) => (
+            <Card
+              key={monthKey}
+              className={`p-6 cursor-pointer transition-all duration-200 ${
+                selectedMonth === monthKey
+                  ? 'ring-2 ring-blue-500 bg-blue-50 dark:bg-blue-900/20'
+                  : 'hover:shadow-md'
+              }`}
+              glass={false}
+              onClick={() => {
+                setSelectedMonth(monthKey);
+                setSelectedWeek(null);
+              }}
+            >
+              <div className="text-center space-y-3">
+                <div className="text-4xl">{monthData.icon}</div>
+                <h3 className="text-lg font-semibold text-[var(--color-text-primary)]">
+                  {monthKey}
+                </h3>
+                <p className="text-[var(--color-text-secondary)]">
+                  {monthData.name}
+                </p>
+              </div>
+            </Card>
+          ))}
+        </div>
+
+        {/* Week Selection */}
+        {selectedMonth && (
+          <Card className="p-6" glass={false}>
+            <h3 className="text-lg font-semibold text-[var(--color-text-primary)] mb-4 text-center">
+              {CORE_PHRASES[selectedMonth as keyof typeof CORE_PHRASES].name} - ì£¼ì°¨ ì„ íƒ
+            </h3>
+            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
+              {Object.entries(CORE_PHRASES[selectedMonth as keyof typeof CORE_PHRASES].weeks).map(([weekKey, weekData]) => (
+                <Card
+                  key={weekKey}
+                  className={`p-4 cursor-pointer transition-all duration-200 ${
+                    selectedWeek === weekKey
+                      ? 'ring-2 ring-green-500 bg-green-50 dark:bg-green-900/20'
+                      : 'hover:shadow-sm bg-[var(--color-bg-secondary)]'
+                  }`}
+                  glass={false}
+                  onClick={() => setSelectedWeek(weekKey)}
+                >
+                  <div className="text-center space-y-2">
+                    <div className="text-2xl">{weekData.icon}</div>
+                    <h4 className="font-medium text-[var(--color-text-primary)]">
+                      {weekKey}
+                    </h4>
+                    <p className="text-sm text-[var(--color-text-secondary)]">
+                      {weekData.name}
+                    </p>
+                    <Badge variant="info" size="sm">
+                      {weekData.phrases.length}ê°œ íŒ¨í„´
+                    </Badge>
+                  </div>
+                </Card>
+              ))}
+            </div>
+          </Card>
+        )}
+
+        {/* Start Practice Button */}
+        {selectedMonth && selectedWeek && (
+          <Card className="p-6 text-center" glass={false}>
+            <div className="space-y-4">
+              <h4 className="text-lg font-semibold text-[var(--color-text-primary)]">
+                ì¤€ë¹„ ì™„ë£Œ! íŒ¨í„´ ì—°ìŠµì„ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?
+              </h4>
+              {progress && (
+                <div className="text-sm text-[var(--color-text-secondary)]">
+                  ì´ì „ ì ìˆ˜: {progress.score}ì  ({progress.completedQuestions.length}ë¬¸ì œ ì™„ë£Œ)
+                </div>
+              )}
+              <Button
+                onClick={generateQuestions}
+                disabled={loading}
+                variant="primary"
+                size="lg"
+              >
+                {loading ? 'AI ë¬¸ì œ ìƒì„± ì¤‘...' : 'ğŸš€ íŒ¨í„´ ì—°ìŠµ ì‹œì‘í•˜ê¸°'}
+              </Button>
+            </div>
+          </Card>
+        )}
+
+        {error && (
+          <Card className="p-4 bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800">
+            <p className="text-red-800 dark:text-red-200 text-sm">{error}</p>
+          </Card>
+        )}
+      </div>
+    );
+  }
+
+  // Render practice session
+  if (mode === 'practice' && questions.length > 0) {
+    const currentQuestion = questions[currentQuestionIndex];
+    const progressPercent = Math.round(((currentQuestionIndex + 1) / questions.length) * 100);
+
+    // Get current week name safely
+    const getCurrentWeekName = () => {
+      if (!selectedMonth || !selectedWeek) return 'íŒ¨í„´ ì—°ìŠµ';
+      const monthData = CORE_PHRASES[selectedMonth as keyof typeof CORE_PHRASES];
+      if (!monthData) return 'íŒ¨í„´ ì—°ìŠµ';
+      const weekData = monthData.weeks[selectedWeek as keyof typeof monthData.weeks];
+      return weekData ? weekData.name : 'íŒ¨í„´ ì—°ìŠµ';
+    };
+
+    return (
+      <div className="space-y-6">
+        {/* Progress Header */}
+        <Card className="p-4" glass={false}>
+          <div className="flex justify-between items-center mb-2">
+            <h3 className="text-lg font-semibold text-[var(--color-text-primary)]">
+              ğŸ“ {selectedMonth} - {getCurrentWeekName()}
+            </h3>
+            <Button
+              onClick={resetToSelection}
+              variant="outline"
+              size="sm"
+            >
+              ì„ íƒìœ¼ë¡œ ëŒì•„ê°€ê¸°
+            </Button>
+          </div>
+          <div className="w-full bg-[var(--color-bg-tertiary)] rounded-full h-2 mb-2">
+            <div
+              className="bg-gradient-to-r from-blue-500 to-green-500 h-2 rounded-full transition-all duration-300"
+              style={{ width: `${progressPercent}%` }}
+            />
+          </div>
+          <p className="text-sm text-[var(--color-text-secondary)]">
+            {currentQuestionIndex + 1} / {questions.length} ({progressPercent}% ì™„ë£Œ)
+          </p>
+        </Card>
+
+        {/* Question Card */}
+        <Card className="p-8" glass={false}>
+          <div className="space-y-6">
+            <div className="text-center">
+              <Badge
+                variant={
+                  currentQuestion.type === 'fill_blank' ? 'primary' :
+                  currentQuestion.type === 'complete_sentence' ? 'success' : 'warning'
+                }
+                size="sm"
+                className="mb-4"
+              >
+                {currentQuestion.type === 'fill_blank' ? 'ë¹ˆì¹¸ ì±„ìš°ê¸°' :
+                 currentQuestion.type === 'complete_sentence' ? 'ë¬¸ì¥ ì™„ì„±' : 'íŒ¨í„´ ë³€í˜•'}
+              </Badge>
+              <h4 className="text-xl font-semibold text-[var(--color-text-primary)] mb-4">
+                ë¬¸ì œ {currentQuestionIndex + 1}
+              </h4>
+            </div>
+
+            {/* Original Phrase */}
+            <div className="bg-[var(--color-bg-secondary)] p-4 rounded-lg text-center">
+              <p className="text-sm text-[var(--color-text-secondary)] mb-1">ì›ë³¸ íŒ¨í„´:</p>
+              <p className="text-lg font-medium text-[var(--color-text-primary)]">
+                "{currentQuestion.originalPhrase}"
+              </p>
+            </div>
+
+            {/* Question */}
+            <div className="text-center">
+              <p className="text-lg text-[var(--color-text-primary)] mb-6">
+                {currentQuestion.question}
+              </p>
+
+              {/* Answer Options */}
+              {currentQuestion.options ? (
+                <div className="grid grid-cols-1 gap-3 max-w-md mx-auto">
+                  {currentQuestion.options.map((option, index) => (
+                    <Button
+                      key={index}
+                      onClick={() => handleAnswer(currentQuestion.id, option)}
+                      variant={userAnswers[currentQuestion.id] === option ? 'primary' : 'outline'}
+                      className="text-left justify-start"
+                    >
+                      {index + 1}. {option}
+                    </Button>
+                  ))}
+                </div>
+              ) : (
+                <div className="max-w-md mx-auto">
+                  <textarea
+                    value={userAnswers[currentQuestion.id] || ''}
+                    onChange={(e) => handleAnswer(currentQuestion.id, e.target.value)}
+                    placeholder="ë‹µì„ ì…ë ¥í•˜ì„¸ìš”..."
+                    className="w-full p-4 border rounded-lg resize-none h-24 bg-[var(--color-bg-primary)]"
+                  />
+                </div>
+              )}
+            </div>
+
+            {/* Explanation */}
+            {currentQuestion.explanation && (
+              <div className="bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded-lg">
+                <p className="text-sm text-yellow-800 dark:text-yellow-200">
+                  ğŸ’¡ <strong>íŒíŠ¸:</strong> {currentQuestion.explanation}
+                </p>
+              </div>
+            )}
+
+            {/* Next Button */}
+            <div className="text-center">
+              <Button
+                onClick={nextQuestion}
+                disabled={!userAnswers[currentQuestion.id]}
+                variant="primary"
+                size="lg"
+              >
+                {currentQuestionIndex < questions.length - 1 ? 'ë‹¤ìŒ ë¬¸ì œ â†’' : 'ì™„ë£Œ! ê²°ê³¼ ë³´ê¸° ğŸ‰'}
+              </Button>
+            </div>
+          </div>
+        </Card>
+      </div>
+    );
+  }
+
+  // Render results
+  if (mode === 'results' && progress) {
+    return (
+      <Card className="p-8 text-center" glass={false}>
+        <div className="space-y-6">
+          <span className="text-6xl">ğŸ‰</span>
+          <h2 className="text-2xl font-bold text-[var(--color-text-primary)]">
+            íŒ¨í„´ ì—°ìŠµ ì™„ë£Œ!
+          </h2>
+
+          {/* Score */}
+          <div className="bg-gradient-to-br from-blue-50 to-green-50 dark:from-blue-900/20 dark:to-green-900/20 p-6 rounded-lg">
+            <h3 className="text-lg font-semibold text-[var(--color-text-primary)] mb-2">
+              ğŸ“Š ìµœì¢… ì ìˆ˜
+            </h3>
+            <p className="text-4xl font-bold text-blue-600 dark:text-blue-400 mb-2">
+              {progress.score}ì 
+            </p>
+            <p className="text-sm text-[var(--color-text-secondary)]">
+              {progress.completedQuestions.length}ë¬¸ì œ ì™„ë£Œ
+            </p>
+          </div>
+
+          {/* Performance Analysis */}
+          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
+            <div className="p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
+              <h4 className="font-medium text-blue-700 dark:text-blue-200 mb-1">ì •í™•ë„</h4>
+              <p className="text-xl font-bold text-blue-600 dark:text-blue-300">
+                {Math.round((progress.score / questions.length) * 10)}%
+              </p>
+            </div>
+            <div className="p-4 bg-green-50 dark:bg-green-900/20 rounded-lg">
+              <h4 className="font-medium text-green-700 dark:text-green-200 mb-1">ì™„ë£Œ ë¬¸ì œ</h4>
+              <p className="text-xl font-bold text-green-600 dark:text-green-300">
+                {progress.completedQuestions.length}ê°œ
+              </p>
+            </div>
+            <div className="p-4 bg-purple-50 dark:bg-purple-900/20 rounded-lg">
+              <h4 className="font-medium text-purple-700 dark:text-purple-200 mb-1">íŒ¨í„´ ìŠµë“</h4>
+              <p className="text-xl font-bold text-purple-600 dark:text-purple-300">
+                {(() => {
+                  if (!selectedMonth || !selectedWeek) return 0;
+                  const monthData = CORE_PHRASES[selectedMonth as keyof typeof CORE_PHRASES];
+                  if (!monthData) return 0;
+                  const weekData = monthData.weeks[selectedWeek as keyof typeof monthData.weeks];
+                  return weekData ? weekData.phrases.length : 0;
+                })()}ê°œ
+              </p>
+            </div>
+          </div>
+
+          {/* Action Buttons */}
+          <div className="flex flex-col sm:flex-row gap-4 justify-center">
+            <Button
+              onClick={() => {
+                setMode('practice');
+                setCurrentQuestionIndex(0);
+                setUserAnswers({});
+                generateQuestions();
+              }}
+              variant="outline"
+            >
+              ë‹¤ì‹œ ì—°ìŠµí•˜ê¸°
+            </Button>
+            <Button
+              onClick={resetToSelection}
+              variant="primary"
+            >
+              ë‹¤ë¥¸ íŒ¨í„´ ì„ íƒí•˜ê¸°
+            </Button>
+          </div>
+        </div>
+      </Card>
+    );
+  }
+
+  return (
+    <div className="text-center py-8">
+      <div className="text-[var(--color-text-primary)]">ë¡œë”© ì¤‘...</div>
+    </div>
+  );
+}
\ No newline at end of file
diff --git a/components/christine/RolePlayConversation.tsx b/components/christine/RolePlayConversation.tsx
new file mode 100644
index 0000000..6c46580
--- /dev/null
+++ b/components/christine/RolePlayConversation.tsx
@@ -0,0 +1,601 @@
+'use client';
+
+/**
+ * Role-play Conversation Component
+ *
+ * Christineì˜ Role-play ëŒ€í™” ì—°ìŠµ ê¸°ëŠ¥:
+ * - ì‚¬ìš©ì ì…ë ¥ ìƒí™© ê¸°ë°˜ AI ëŒ€í™” ìƒì„±
+ * - ì‹¤ì‹œê°„ ëŒ€í™” ì—°ìŠµ
+ * - ìì—°ìŠ¤ëŸ¬ìš´ í‘œí˜„ í•™ìŠµ
+ * - ë§ì¶¤í˜• í”¼ë“œë°± ì œê³µ
+ */
+
+import React, { useState, useEffect, useRef } from 'react';
+import { useSession } from 'next-auth/react';
+import Card from '@/components/ui/Card';
+import Button from '@/components/ui/Button';
+import Badge from '@/components/ui/Badge';
+
+interface ConversationMessage {
+  id: string;
+  role: 'user' | 'ai' | 'system';
+  content: string;
+  timestamp: number;
+  feedback?: MessageFeedback;
+}
+
+interface MessageFeedback {
+  score: number;
+  naturalness: string;
+  suggestions: string[];
+  improvedVersion?: string;
+}
+
+interface ConversationSession {
+  id: string;
+  scenario: string;
+  context: string;
+  messages: ConversationMessage[];
+  totalScore: number;
+  completedTurns: number;
+}
+
+type ConversationMode = 'setup' | 'conversation' | 'feedback' | 'summary';
+
+// Predefined scenarios for quick start
+const QUICK_SCENARIOS = [
+  {
+    title: 'ê³µí•­ì—ì„œ ì²´í¬ì¸í•˜ê¸°',
+    icon: 'âœˆï¸',
+    scenario: 'airport_checkin',
+    context: 'ë‹¹ì‹ ì€ í•´ì™¸ì—¬í–‰ì„ ìœ„í•´ ê³µí•­ì— ë„ì°©í–ˆìŠµë‹ˆë‹¤. í•­ê³µì‚¬ ì¹´ìš´í„°ì—ì„œ ì²´í¬ì¸ì„ í•˜ë ¤ê³  í•©ë‹ˆë‹¤.',
+    difficulty: 'beginner'
+  },
+  {
+    title: 'ë ˆìŠ¤í† ë‘ì—ì„œ ì£¼ë¬¸í•˜ê¸°',
+    icon: 'ğŸ½ï¸',
+    scenario: 'restaurant_order',
+    context: 'ë‹¹ì‹ ì€ ì™¸êµ­ ë ˆìŠ¤í† ë‘ì—ì„œ ì‹ì‚¬ë¥¼ í•˜ë ¤ê³  í•©ë‹ˆë‹¤. ì„œë²„ì™€ ëŒ€í™”í•˜ë©° ë©”ë‰´ë¥¼ ì£¼ë¬¸í•´ë³´ì„¸ìš”.',
+    difficulty: 'beginner'
+  },
+  {
+    title: 'íšŒì‚¬ ë™ë£Œì™€ ìŠ¤ëª°í† í¬',
+    icon: 'ğŸ’¼',
+    scenario: 'office_smalltalk',
+    context: 'ìƒˆë¡œìš´ ì§ì¥ì—ì„œ ë™ë£Œì™€ ì²˜ìŒ ë§Œë‚¬ìŠµë‹ˆë‹¤. ìì—°ìŠ¤ëŸ½ê²Œ ì¸ì‚¬ë¥¼ ë‚˜ëˆ„ê³  ì¹œí•´ì ¸ë³´ì„¸ìš”.',
+    difficulty: 'intermediate'
+  },
+  {
+    title: 'í˜¸í…”ì—ì„œ ë¬¸ì œ í•´ê²°í•˜ê¸°',
+    icon: 'ğŸ¨',
+    scenario: 'hotel_complaint',
+    context: 'í˜¸í…” ë°©ì— ë¬¸ì œê°€ ìˆì–´ì„œ í”„ëŸ°íŠ¸ ë°ìŠ¤í¬ì— ë„ì›€ì„ ìš”ì²­í•´ì•¼ í•©ë‹ˆë‹¤.',
+    difficulty: 'intermediate'
+  },
+  {
+    title: 'ë¹„ì¦ˆë‹ˆìŠ¤ ë¯¸íŒ… ì§„í–‰',
+    icon: 'ğŸ¤',
+    scenario: 'business_meeting',
+    context: 'ì¤‘ìš”í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¯¸íŒ…ì—ì„œ ë‹¹ì‹ ì˜ ì˜ê²¬ì„ ì œì‹œí•˜ê³  í˜‘ì˜í•´ì•¼ í•©ë‹ˆë‹¤.',
+    difficulty: 'advanced'
+  },
+  {
+    title: 'ì˜ê²¬ì´ ë‹¤ë¥¼ ë•Œ ëŒ€í™”í•˜ê¸°',
+    icon: 'ğŸ’­',
+    scenario: 'disagreement_discussion',
+    context: 'ë™ë£Œë‚˜ ì¹œêµ¬ì™€ ì˜ê²¬ì´ ë‹¤ë¥¸ ìƒí™©ì—ì„œ ì˜ˆì˜ ë°”ë¥´ê²Œ ìì‹ ì˜ ìƒê°ì„ ì „ë‹¬í•´ë³´ì„¸ìš”.',
+    difficulty: 'advanced'
+  }
+];
+
+export function RolePlayConversation() {
+  const { data: session } = useSession();
+  const [mode, setMode] = useState<ConversationMode>('setup');
+  const [customScenario, setCustomScenario] = useState('');
+  const [selectedScenario, setSelectedScenario] = useState<typeof QUICK_SCENARIOS[0] | null>(null);
+  const [currentSession, setCurrentSession] = useState<ConversationSession | null>(null);
+  const [userInput, setUserInput] = useState('');
+  const [loading, setLoading] = useState(false);
+  const [error, setError] = useState<string | null>(null);
+  const messagesEndRef = useRef<HTMLDivElement>(null);
+
+  const userId = session?.user?.name || 'anonymous';
+
+  // Auto scroll to bottom of messages
+  const scrollToBottom = () => {
+    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
+  };
+
+  useEffect(() => {
+    scrollToBottom();
+  }, [currentSession?.messages]);
+
+  // Start new conversation session
+  const startConversation = async () => {
+    if (!selectedScenario && !customScenario.trim()) {
+      setError('ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ì„ íƒí•˜ê±°ë‚˜ ì§ì ‘ ì…ë ¥í•´ì£¼ì„¸ìš”.');
+      return;
+    }
+
+    try {
+      setLoading(true);
+      setError(null);
+
+      const scenario = selectedScenario || {
+        title: 'ì‚¬ìš©ì ì •ì˜ ì‹œë‚˜ë¦¬ì˜¤',
+        scenario: 'custom',
+        context: customScenario.trim(),
+        difficulty: 'intermediate'
+      };
+
+      const response = await fetch('/api/influencers/christine/roleplay', {
+        method: 'POST',
+        headers: {
+          'Content-Type': 'application/json',
+        },
+        body: JSON.stringify({
+          action: 'start_conversation',
+          userId,
+          scenario: scenario.scenario,
+          context: scenario.context,
+          difficulty: scenario.difficulty
+        }),
+      });
+
+      const data = await response.json();
+
+      if (data.success) {
+        setCurrentSession(data.session);
+        setMode('conversation');
+      } else {
+        setError(data.error || 'Failed to start conversation');
+      }
+    } catch (err) {
+      setError('ëŒ€í™” ì‹œì‘ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  // Send user message
+  const sendMessage = async () => {
+    if (!userInput.trim() || !currentSession) return;
+
+    try {
+      setLoading(true);
+      setError(null);
+
+      const response = await fetch('/api/influencers/christine/roleplay', {
+        method: 'POST',
+        headers: {
+          'Content-Type': 'application/json',
+        },
+        body: JSON.stringify({
+          action: 'send_message',
+          userId,
+          sessionId: currentSession.id,
+          message: userInput.trim()
+        }),
+      });
+
+      const data = await response.json();
+
+      if (data.success) {
+        setCurrentSession(data.session);
+        setUserInput('');
+
+        // Check if conversation should end
+        if (data.session.completedTurns >= 6) { // End after 6 turns
+          setTimeout(() => {
+            setMode('summary');
+          }, 2000);
+        }
+      } else {
+        setError(data.error || 'Failed to send message');
+      }
+    } catch (err) {
+      setError('ë©”ì‹œì§€ ì „ì†¡ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  // Get feedback for a specific message
+  const getFeedback = async (messageId: string) => {
+    if (!currentSession) return;
+
+    try {
+      setLoading(true);
+
+      const response = await fetch('/api/influencers/christine/roleplay', {
+        method: 'POST',
+        headers: {
+          'Content-Type': 'application/json',
+        },
+        body: JSON.stringify({
+          action: 'get_feedback',
+          userId,
+          sessionId: currentSession.id,
+          messageId
+        }),
+      });
+
+      const data = await response.json();
+
+      if (data.success) {
+        setCurrentSession(data.session);
+      } else {
+        setError(data.error || 'Failed to get feedback');
+      }
+    } catch (err) {
+      setError('í”¼ë“œë°± ìš”ì²­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  // Reset to setup
+  const resetToSetup = () => {
+    setMode('setup');
+    setCurrentSession(null);
+    setSelectedScenario(null);
+    setCustomScenario('');
+    setUserInput('');
+    setError(null);
+  };
+
+  // Render setup mode
+  if (mode === 'setup') {
+    return (
+      <div className="space-y-6">
+        {/* Header */}
+        <Card className="p-6" glass={false}>
+          <div className="text-center space-y-4">
+            <div className="w-20 h-20 mx-auto bg-gradient-to-br from-green-500/20 to-teal-500/20 rounded-full flex items-center justify-center">
+              <span className="text-4xl">ğŸ­</span>
+            </div>
+            <h2 className="text-2xl font-bold text-[var(--color-text-primary)]">
+              Role-play ëŒ€í™” ì—°ìŠµ
+            </h2>
+            <p className="text-[var(--color-text-secondary)] max-w-2xl mx-auto">
+              ì‹¤ì œ ìƒí™©ì„ ì‹œë®¬ë ˆì´ì…˜í•˜ì—¬ ìì—°ìŠ¤ëŸ¬ìš´ ì˜ì–´ ëŒ€í™” ëŠ¥ë ¥ì„ ê¸°ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
+              AIì™€ í•¨ê»˜ ë‹¤ì–‘í•œ ìƒí™©ì—ì„œ ëŒ€í™”ë¥¼ ì—°ìŠµí•´ë³´ì„¸ìš”!
+            </p>
+          </div>
+        </Card>
+
+        {/* Quick Scenarios */}
+        <Card className="p-6" glass={false}>
+          <h3 className="text-lg font-semibold text-[var(--color-text-primary)] mb-4">
+            ğŸš€ ë¹ ë¥¸ ì‹œì‘ - ì¶”ì²œ ì‹œë‚˜ë¦¬ì˜¤
+          </h3>
+          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
+            {QUICK_SCENARIOS.map((scenario, index) => (
+              <Card
+                key={index}
+                className={`p-4 cursor-pointer transition-all duration-200 ${
+                  selectedScenario === scenario
+                    ? 'ring-2 ring-green-500 bg-green-50 dark:bg-green-900/20'
+                    : 'hover:shadow-sm bg-[var(--color-bg-secondary)]'
+                }`}
+                glass={false}
+                onClick={() => {
+                  setSelectedScenario(scenario);
+                  setCustomScenario('');
+                }}
+              >
+                <div className="space-y-3">
+                  <div className="flex items-center gap-2">
+                    <span className="text-2xl">{scenario.icon}</span>
+                    <Badge
+                      variant={
+                        scenario.difficulty === 'beginner' ? 'success' :
+                        scenario.difficulty === 'intermediate' ? 'warning' : 'danger'
+                      }
+                      size="sm"
+                    >
+                      {scenario.difficulty === 'beginner' ? 'ì´ˆê¸‰' :
+                       scenario.difficulty === 'intermediate' ? 'ì¤‘ê¸‰' : 'ê³ ê¸‰'}
+                    </Badge>
+                  </div>
+                  <h4 className="font-medium text-[var(--color-text-primary)]">
+                    {scenario.title}
+                  </h4>
+                  <p className="text-sm text-[var(--color-text-secondary)]">
+                    {scenario.context}
+                  </p>
+                </div>
+              </Card>
+            ))}
+          </div>
+        </Card>
+
+        {/* Custom Scenario */}
+        <Card className="p-6" glass={false}>
+          <h3 className="text-lg font-semibold text-[var(--color-text-primary)] mb-4">
+            âœï¸ ì‚¬ìš©ì ì •ì˜ ì‹œë‚˜ë¦¬ì˜¤
+          </h3>
+          <div className="space-y-4">
+            <textarea
+              value={customScenario}
+              onChange={(e) => {
+                setCustomScenario(e.target.value);
+                if (e.target.value.trim()) {
+                  setSelectedScenario(null);
+                }
+              }}
+              placeholder="ì›í•˜ëŠ” ìƒí™©ì„ ìì„¸íˆ ì„¤ëª…í•´ì£¼ì„¸ìš”. ì˜ˆ: 'ì¹´í˜ì—ì„œ ì¹œêµ¬ì™€ ë§Œë‚˜ì„œ ìµœê·¼ ê·¼í™©ì„ ë‚˜ëˆ„ëŠ” ìƒí™©', 'ì˜¨ë¼ì¸ ì‡¼í•‘ëª°ì— ì „í™”í•´ì„œ ë°˜í’ˆ ë¬¸ì˜ë¥¼ í•˜ëŠ” ìƒí™©' ë“±"
+              className="w-full p-4 border rounded-lg resize-none h-24 bg-[var(--color-bg-primary)]"
+            />
+            <p className="text-sm text-[var(--color-text-tertiary)]">
+              ğŸ’¡ êµ¬ì²´ì ì´ê³  ìƒì„¸í•œ ìƒí™© ì„¤ëª…ì¼ìˆ˜ë¡ ë” ë§ì¶¤í˜• ëŒ€í™”ë¥¼ ì—°ìŠµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
+            </p>
+          </div>
+        </Card>
+
+        {/* Start Button */}
+        <Card className="p-6 text-center" glass={false}>
+          <div className="space-y-4">
+            <h4 className="text-lg font-semibold text-[var(--color-text-primary)]">
+              {selectedScenario ? selectedScenario.title : customScenario ? 'ì‚¬ìš©ì ì •ì˜ ì‹œë‚˜ë¦¬ì˜¤' : 'ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”'}
+            </h4>
+            {(selectedScenario || customScenario) && (
+              <p className="text-sm text-[var(--color-text-secondary)] max-w-2xl mx-auto">
+                {selectedScenario ? selectedScenario.context : customScenario}
+              </p>
+            )}
+            <Button
+              onClick={startConversation}
+              disabled={loading || (!selectedScenario && !customScenario.trim())}
+              variant="primary"
+              size="lg"
+            >
+              {loading ? 'AI ì¤€ë¹„ ì¤‘...' : 'ğŸ­ Role-play ì‹œì‘í•˜ê¸°'}
+            </Button>
+          </div>
+        </Card>
+
+        {error && (
+          <Card className="p-4 bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800">
+            <p className="text-red-800 dark:text-red-200 text-sm">{error}</p>
+          </Card>
+        )}
+      </div>
+    );
+  }
+
+  // Render conversation mode
+  if (mode === 'conversation' && currentSession) {
+    return (
+      <div className="space-y-6">
+        {/* Header */}
+        <Card className="p-4" glass={false}>
+          <div className="flex justify-between items-center">
+            <div>
+              <h3 className="text-lg font-semibold text-[var(--color-text-primary)]">
+                ğŸ­ {selectedScenario?.title || 'ì‚¬ìš©ì ì •ì˜ ì‹œë‚˜ë¦¬ì˜¤'}
+              </h3>
+              <p className="text-sm text-[var(--color-text-secondary)]">
+                ì§„í–‰: {currentSession.completedTurns}/6 í„´
+              </p>
+            </div>
+            <Button
+              onClick={resetToSetup}
+              variant="outline"
+              size="sm"
+            >
+              ìƒˆ ì‹œë‚˜ë¦¬ì˜¤ ì„ íƒ
+            </Button>
+          </div>
+        </Card>
+
+        {/* Conversation Area */}
+        <Card className="p-6" glass={false}>
+          <div className="space-y-4 max-h-96 overflow-y-auto">
+            {currentSession.messages.map((message) => (
+              <div
+                key={message.id}
+                className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}
+              >
+                <div
+                  className={`max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${
+                    message.role === 'user'
+                      ? 'bg-blue-500 text-white'
+                      : message.role === 'system'
+                      ? 'bg-yellow-100 dark:bg-yellow-900/20 text-yellow-800 dark:text-yellow-200 text-sm'
+                      : 'bg-[var(--color-bg-secondary)] text-[var(--color-text-primary)]'
+                  }`}
+                >
+                  <p>{message.content}</p>
+
+                  {/* Feedback section for user messages */}
+                  {message.role === 'user' && (
+                    <div className="mt-2">
+                      {message.feedback ? (
+                        <div className="text-xs bg-white/20 p-2 rounded mt-2">
+                          <div className="flex items-center gap-1 mb-1">
+                            <span>ì ìˆ˜: {message.feedback.score}/10</span>
+                            <Badge variant="success" size="sm">í”¼ë“œë°±</Badge>
+                          </div>
+                          <p className="mb-1">{message.feedback.naturalness}</p>
+                          {message.feedback.suggestions.length > 0 && (
+                            <div>
+                              <p className="text-xs opacity-75 mb-1">ê°œì„  ì œì•ˆ:</p>
+                              <ul className="text-xs opacity-75">
+                                {message.feedback.suggestions.map((suggestion, idx) => (
+                                  <li key={idx}>â€¢ {suggestion}</li>
+                                ))}
+                              </ul>
+                            </div>
+                          )}
+                          {message.feedback.improvedVersion && (
+                            <p className="text-xs bg-white/10 p-1 rounded mt-1">
+                              ê°œì„ : "{message.feedback.improvedVersion}"
+                            </p>
+                          )}
+                        </div>
+                      ) : (
+                        <Button
+                          onClick={() => getFeedback(message.id)}
+                          variant="outline"
+                          size="sm"
+                          className="text-xs mt-2 opacity-75 hover:opacity-100"
+                        >
+                          í”¼ë“œë°± ìš”ì²­
+                        </Button>
+                      )}
+                    </div>
+                  )}
+                </div>
+              </div>
+            ))}
+            <div ref={messagesEndRef} />
+          </div>
+
+          {/* Input Area */}
+          <div className="mt-6 space-y-4">
+            <div className="flex gap-3">
+              <textarea
+                value={userInput}
+                onChange={(e) => setUserInput(e.target.value)}
+                placeholder="ì˜ì–´ë¡œ ë‹µë³€ì„ ì…ë ¥í•˜ì„¸ìš”..."
+                className="flex-1 p-3 border rounded-lg resize-none h-20 bg-[var(--color-bg-primary)]"
+                disabled={loading}
+                onKeyPress={(e) => {
+                  if (e.key === 'Enter' && !e.shiftKey) {
+                    e.preventDefault();
+                    sendMessage();
+                  }
+                }}
+              />
+              <Button
+                onClick={sendMessage}
+                disabled={loading || !userInput.trim()}
+                variant="primary"
+                className="h-20"
+              >
+                {loading ? 'ì „ì†¡ ì¤‘...' : 'ì „ì†¡'}
+              </Button>
+            </div>
+
+            <div className="text-xs text-[var(--color-text-tertiary)] text-center">
+              ğŸ’¡ Enterë¥¼ ëˆŒëŸ¬ ì „ì†¡, Shift+Enterë¡œ ì¤„ë°”ê¿ˆ
+            </div>
+          </div>
+        </Card>
+
+        {error && (
+          <Card className="p-4 bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800">
+            <p className="text-red-800 dark:text-red-200 text-sm">{error}</p>
+          </Card>
+        )}
+      </div>
+    );
+  }
+
+  // Render summary mode
+  if (mode === 'summary' && currentSession) {
+    const userMessages = currentSession.messages.filter(m => m.role === 'user');
+    const avgScore = userMessages.reduce((sum, msg) => sum + (msg.feedback?.score || 0), 0) / userMessages.length;
+
+    return (
+      <Card className="p-8 text-center" glass={false}>
+        <div className="space-y-6">
+          <span className="text-6xl">ğŸ‰</span>
+          <h2 className="text-2xl font-bold text-[var(--color-text-primary)]">
+            ëŒ€í™” ì—°ìŠµ ì™„ë£Œ!
+          </h2>
+
+          {/* Final Score */}
+          <div className="bg-gradient-to-br from-green-50 to-blue-50 dark:from-green-900/20 dark:to-blue-900/20 p-6 rounded-lg">
+            <h3 className="text-lg font-semibold text-[var(--color-text-primary)] mb-2">
+              ğŸ“Š ì¢…í•© í‰ê°€
+            </h3>
+            <p className="text-4xl font-bold text-green-600 dark:text-green-400 mb-2">
+              {Math.round(avgScore * 10)}/100
+            </p>
+            <p className="text-sm text-[var(--color-text-secondary)]">
+              ì´ {currentSession.completedTurns}í„´ ì™„ë£Œ
+            </p>
+          </div>
+
+          {/* Detailed Analysis */}
+          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
+            <div className="p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
+              <h4 className="font-medium text-blue-700 dark:text-blue-200 mb-1">ìì—°ìŠ¤ëŸ¬ì›€</h4>
+              <p className="text-xl font-bold text-blue-600 dark:text-blue-300">
+                {avgScore >= 8 ? 'ë§¤ìš° ì¢‹ìŒ' : avgScore >= 6 ? 'ì¢‹ìŒ' : 'ë³´í†µ'}
+              </p>
+            </div>
+            <div className="p-4 bg-green-50 dark:bg-green-900/20 rounded-lg">
+              <h4 className="font-medium text-green-700 dark:text-green-200 mb-1">ì°¸ì—¬ë„</h4>
+              <p className="text-xl font-bold text-green-600 dark:text-green-300">
+                {currentSession.completedTurns}/6í„´
+              </p>
+            </div>
+            <div className="p-4 bg-purple-50 dark:bg-purple-900/20 rounded-lg">
+              <h4 className="font-medium text-purple-700 dark:text-purple-200 mb-1">í‘œí˜„ë ¥</h4>
+              <p className="text-xl font-bold text-purple-600 dark:text-purple-300">
+                {userMessages.length}ê°œ í‘œí˜„
+              </p>
+            </div>
+          </div>
+
+          {/* Recommendations */}
+          <div className="bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded-lg text-left">
+            <h4 className="font-medium text-yellow-800 dark:text-yellow-200 mb-2">
+              ğŸ’¡ ë‹¤ìŒ ë‹¨ê³„ ì¶”ì²œ
+            </h4>
+            <ul className="text-sm text-yellow-700 dark:text-yellow-100 space-y-1">
+              {avgScore >= 8 ? (
+                <>
+                  <li>â€¢ ë” ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ìƒí™©ì— ë„ì „í•´ë³´ì„¸ìš”</li>
+                  <li>â€¢ ì˜ê²¬ì´ ë‹¤ë¥¸ ìƒí™©ì—ì„œì˜ ëŒ€í™”ë¥¼ ì—°ìŠµí•´ë³´ì„¸ìš”</li>
+                  <li>â€¢ ì‹¤ì œ ì›ì–´ë¯¼ê³¼ì˜ ëŒ€í™”ì— ìì‹ ê°ì„ ê°€ì§€ì„¸ìš”!</li>
+                </>
+              ) : avgScore >= 6 ? (
+                <>
+                  <li>â€¢ ë‹¤ì–‘í•œ í‘œí˜„ì„ ì‚¬ìš©í•´ë³´ì„¸ìš”</li>
+                  <li>â€¢ ê°™ì€ ìƒí™©ì„ ë‹¤ì‹œ ì—°ìŠµí•´ì„œ ì™„ë²½í•˜ê²Œ ë§Œë“¤ì–´ë³´ì„¸ìš”</li>
+                  <li>â€¢ Core Phrase íŒ¨í„´ ì—°ìŠµìœ¼ë¡œ ê¸°ë³¸ê¸°ë¥¼ ë‹¤ì ¸ë³´ì„¸ìš”</li>
+                </>
+              ) : (
+                <>
+                  <li>â€¢ ê¸°ë³¸ íŒ¨í„´ë¶€í„° ì°¨ê·¼ì°¨ê·¼ ì—°ìŠµí•˜ì„¸ìš”</li>
+                  <li>â€¢ ê°„ë‹¨í•œ ìƒí™©ë¶€í„° ì‹œì‘í•´ë³´ì„¸ìš”</li>
+                  <li>â€¢ í”¼ë“œë°±ì„ ê¼¼ê¼¼íˆ í™•ì¸í•˜ê³  ê°œì„ í•´ë³´ì„¸ìš”</li>
+                </>
+              )}
+            </ul>
+          </div>
+
+          {/* Action Buttons */}
+          <div className="flex flex-col sm:flex-row gap-4 justify-center">
+            <Button
+              onClick={() => {
+                setMode('conversation');
+                setCurrentSession(null);
+                startConversation();
+              }}
+              variant="outline"
+            >
+              ê°™ì€ ì‹œë‚˜ë¦¬ì˜¤ ë‹¤ì‹œ ì—°ìŠµ
+            </Button>
+            <Button
+              onClick={resetToSetup}
+              variant="primary"
+            >
+              ìƒˆë¡œìš´ ì‹œë‚˜ë¦¬ì˜¤ ì„ íƒ
+            </Button>
+          </div>
+        </div>
+      </Card>
+    );
+  }
+
+  return (
+    <div className="text-center py-8">
+      <div className="text-[var(--color-text-primary)]">ë¡œë”© ì¤‘...</div>
+    </div>
+  );
+}
\ No newline at end of file
-- 
2.39.3 (Apple Git-146)

